object "EXEC404_10272" {
    code {
        {
            let _1 := memoryguard(0x0160)
            mstore(64, _1)
            if callvalue() { revert(0, 0) }
            let programSize := datasize("EXEC404_10272")
            let argSize := sub(codesize(), programSize)
            finalize_allocation(_1, argSize)
            codecopy(_1, programSize, argSize)
            let _2 := add(_1, argSize)
            if slt(sub(_2, _1), 32)
            {
                revert( 0, 0)
            }
            let offset := mload(_1)
            if gt(offset, sub(shl(64, 1), 1))
            {
                revert( 0, 0)
            }
            let _3 := add(_1, offset)
            if iszero(slt(add(_3, 0x1f), _2))
            {
                revert( 0, 0)
            }
            let length := mload(_3)
            if gt(length, sub(shl(64, 1), 1))
            {
                mstore( shl(224, 0x4e487b71))
                mstore(4, 0x41)
                revert( 0x24)
            }
            let _4 := shl(5, length)
            let memPtr := mload(64)
            finalize_allocation(memPtr, add(_4, 32))
            let dst := memPtr
            mstore(memPtr, length)
            dst := add(memPtr, 32)
            let dst_1 := dst
            let srcEnd := add(add(_3, _4), 32)
            if gt(srcEnd, _2)
            {
                revert( 0, 0)
            }
            let src := add(_3, 32)
            for { } lt(src, srcEnd) { src := add(src, 32) }
            {
                mstore(dst, mload(src))
                dst := add(dst, 32)
            }
            mstore(128, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
            mstore(160, 0xe592427a0aece92de3edee1f18e0157c05861564)
            mstore(192, 0xc36442b4a4522e871399cd717abdd847ab11fe88)
            mstore(256, 0x1f98431c8ad98523631ae4a59f267346ea31f984)
            if iszero( 0x0c))
            {
                let memPtr_1 := mload(64)
                mstore(memPtr_1, shl(229, 4594637))
                mstore(add(memPtr_1, 4), 32)
                mstore(add(memPtr_1, 36), 20)
                mstore(add(memPtr_1, 68), "Invalid roots length")
                revert(memPtr_1, 100)
            }
            let length_1 := mload(memPtr)
            if gt(length_1, sub(shl(64, 1), 1))
            {
                mstore( shl(224, 0x4e487b71))
                mstore(4, 0x41)
                revert( 0x24)
            }
            if gt(length_1, 18446744073709551616)
            {
                mstore( shl(224, 0x4e487b71))
                mstore(4, 0x41)
                revert( 0x24)
            }
            let oldLen := sload( 0x02)
            sstore( length_1)
            if lt(length_1, oldLen)
            {
                mstore( 0x02)
                let data := keccak256( 32)
                let _5 := add(data, oldLen)
                let start := add(data, length_1)
                for { } lt(start, _5) { start := add(start, 1) }
                {
                    sstore(start, 0)
                }
            }
            let srcPtr := dst_1
            mstore( 0x02)
            let data_1 := keccak256( 32)
            let i := 0
            for { } lt(i, length_1) { i := add(i, 1) }
            {
                let _6 := mload(srcPtr)
                srcPtr := add(srcPtr, 32)
                sstore(add(data_1, i), _6)
            }
            mstore(320, timestamp())
            let cleaned := and(mload( sub(shl(160, 1), 1))
            let _7 := mload(64)
            mstore(_7, shl(224, 0xc45a0155))
            let _8 := staticcall(gas(), cleaned, _7, 4, _7, 32)
            if iszero(_8)
            {
                let pos := mload(64)
                returndatacopy(pos, returndatasize())
                revert(pos, returndatasize())
            }
            let expr := 0
            if _8
            {
                let _9 := 32
                if gt( returndatasize()) { _9 := returndatasize() }
                finalize_allocation(_7, _9)
                expr := abi_decode_address_fromMemory(_7, add(_7, _9))
            }
            mstore( sub(shl(160, 1), 1)))
            let cleaned_1 := and(mload( sub(shl(160, 1), 1))
            let _10 := mload(64)
            mstore(_10, shl(227, 0x15ab88c9))
            let _11 := staticcall(gas(), cleaned_1, _10, 32)
            if iszero(_11)
            {
                let pos_1 := mload(64)
                returndatacopy(pos_1, returndatasize())
                revert(pos_1, returndatasize())
            }
            let expr_1 := 0
            if _11
            {
                let _12 := 32
                if gt( returndatasize()) { _12 := returndatasize() }
                finalize_allocation(_10, _12)
                expr_1 := abi_decode_address_fromMemory(_10, add(_10, _12))
            }
            mstore(288, expr_1)
            let cleaned_2 := and(mload( sub(shl(160, 1), 1))
            let _13 := mload(64)
            mstore(_13, shl(225, 0x0b4c7741))
            mstore( 0xc5dc95539589fbd24be07c6c14eca4)
            mstore(add( and(expr_1, sub(shl(160, 1), 1)))
            mstore(add( 68), 0x2710)
            let _14 := staticcall(gas(), cleaned_2, _13, 100, _13, 32)
            if iszero(_14)
            {
                let pos_2 := mload(64)
                returndatacopy(pos_2, returndatasize())
                revert(pos_2, returndatasize())
            }
            let expr_2 := 0
            if _14
            {
                let _15 := 32
                if gt( returndatasize()) { _15 := returndatasize() }
                finalize_allocation(_13, _15)
                expr_2 := abi_decode_address_fromMemory(_13, add(_13, _15))
            }
            let _16 := and( sub(shl(160, 1), 1))
            sstore( _16))
            if _16)
            {
                let memPtr_2 := mload(64)
                mstore(memPtr_2, shl(229, 4594637))
                mstore(add(memPtr_2, 32)
                mstore( add(memPtr_2, 36), 23)
                mstore( memPtr_2, 68), "CULT pool doesn't exist")
                revert(memPtr_2, 100)
            }
            let _17 := mload(64)
            let tail := add(_17, 32)
            mstore(_17, 32)
            let pos_3 := tail
            let length_2 := memPtr)
            mstore(tail, length_2)
            pos_3 := 64)
            let srcPtr_1 := dst_1
            let i_1 := 0
            for { }
            lt(i_1, length_2)
            {
                i_1 := add(i_1, 1)
            }
            {
                mstore(pos_3, mload(srcPtr_1))
                pos_3 := add(pos_3, 32)
                srcPtr_1 := add(srcPtr_1, 32)
            }
            log1(_17, sub(pos_3, _17), 0x383225f8fd651ce182a2feb8892f901500f0ef117011b62bff9c3115eaabf6c8)
            let _18 := mload(64)
            let _19 := datasize("DN404Mirror_5061")
            let _20 := add(_18, _19)
            if or(gt(_20, lt(_20, _18))
            {
                mstore( shl(224, 0x4e487b71))
                mstore( 0x41)
                revert( 36)
            }
            datacopy(_18, dataoffset("DN404Mirror_5061"), _19)
            mstore(_20, caller())
            let expr_address := create( 32))
            if iszero(expr_address)
            {
                let pos_4 := mload(64)
                returndatacopy(pos_4, returndatasize())
                revert(pos_4, returndatasize())
            }
            let _21 := and( sub(shl(160, 1), 1))
            if sub(shl(160, 1), 1))))
            {
                mstore( 0xead4d2e4)
                revert(0x1c, 4)
            }
            if _21)
            {
                mstore( 0x39a84a7b)
                revert(0x1c, 4)
            }
            mstore( 0x0f4599e5)
            mstore( caller())
            if iszero(and(eq(mload( 32)))
            {
                mstore( 0xd125259c)
                revert(0x1c, 4)
            }
            mstore( 0x8da5cb5b6cef16e6)
            if and(lt(iszero(shl( 32, 32))
            {
                if iszero(call(gas(), _21, 0, 0))
                {
                    revert( 0, 0)
                }
            }
            sstore( not(0xffffffff00000000)), 0x0100000000))
            sstore( _21))
            if address())
            {
                mstore( 0xea553b34)
                revert( 4)
            }
            sstore( sub(shl(160, 1), 1)), shl(187, 0x01cb15d24956472c0b)))
            let _22 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address( address())
            sstore(_22, or(and(sload(_22), sub(shl(160, 1), 1)), shl(187, 0x01cb15d24956472c0b)))
            mstore( 0x0e58ae924ab2396058000000)
            log3( address())
            let _23 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address( address())
            let _24 := sload( _23)
            let _25 := shr(88, _24)
            mstore( 1)
            log2( address())
            sstore(_23, or(and(_24, not(0xff0000000000000000000000)), and(shl(88, and(_25, 0xff)))), 0xff0000000000000000000000)))
            let _26 := mload(64)
            let _27 := datasize("EXEC404_10272_deployed")
            codecopy(_26, dataoffset("EXEC404_10272_deployed"), _27)
            setimmutable(_26, "7769", mload( 128))
            setimmutable(_26, "7775", mload( 160))
            setimmutable(_26, "7781", mload( 192))
            setimmutable(_26, "7784", mload(224))
            setimmutable(_26, "7790", mload( 256))
            setimmutable(_26, "7794", mload( 288))
            setimmutable(_26, "7799", mload( 320))
            return(_26, _27)
        }
        function finalize_allocation(memPtr, size)
        {
            let newFreePtr := add(memPtr, and(add(size, 31), not(31)))
            if or(gt(newFreePtr, sub(shl(64, 1), 1)), lt(newFreePtr, memPtr))
            {
                mstore( shl(224, 0x4e487b71))
                mstore(4, 0x41)
                revert( 0x24)
            }
            mstore(64, newFreePtr)
        }
        function abi_decode_address_fromMemory(headStart, dataEnd) -> value0
        {
            if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }
            let value := mload(headStart)
            if iszero(eq(value, and(value, sub(shl(160, 1), 1))))
            {
                revert( 0, 0)
            }
            value0 := value
        }
        function mapping_index_access_mapping_address_struct_AddressData_storage_of_address(key) -> dataSlot
        {
            mstore(0, and(key, sub(shl(160, 1), 1)))
            mstore(0x20, 0xa20d6e21d0e5255313)
            dataSlot := keccak256(0, 0x40)
        }
    }
    object "EXEC404_10272_deployed" {
        code {
            {
                let _1 := memoryguard(0x80)
                mstore(64, _1)
                if iszero(lt(calldatasize(), 4))
                {
                    let _2 := 0
                    switch shr(224, calldataload(0))
                    case 0x022466b5 {
                        if callvalue() { revert(0, 0) }
                        if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                        mstore(_1, loadimmutable("7799"))
                        return(_1, 32)
                    }
                    case 0x02efb62d {
                        if callvalue() { revert(0, 0) }
                        if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                        let memPos := mload(64)
                        mstore(memPos, 0x056bc75e2d63100000)
                        return(memPos, 32)
                    }
                    case 0x06fdde03 { external_fun_name() }
                    case 0x08b9cdc4 {
                        if callvalue() { revert(0, 0) }
                        if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                        let memPos_1 := mload(64)
                        mstore(memPos_1, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_1, 32)
                    }
                    case 0x095ea7b3 {
                        if callvalue() { revert(0, 0) }
                        if slt(add(calldatasize(), not(3)), 64) { revert(0, 0) }
                        let value0 := abi_decode_address()
                        fun_approve( calldataload(36))
                        let memPos_2 := mload(64)
                        mstore(memPos_2, 1)
                        return(memPos_2, 32)
                    }
                    case 0x150b7a02 {
                        if callvalue() { revert(0, 0) }
                        if slt(add(calldatasize(), not(3)), 128) { revert(0, 0) }
                        pop(abi_decode_address())
                        pop(abi_decode_address_38719())
                        let offset := calldataload(100)
                        if gt(offset, 0xffffffffffffffff) { revert(0, 0) }
                        let value3, value4 := abi_decode_bytes_calldata(add(4, offset), calldatasize())
                        let memPos_3 := mload(64)
                        mstore(memPos_3, 0x150b7a0200000000000000000000000000000000000000000000000000000000)
                        return(memPos_3, 32)
                    }
                    case 0x174f901b {
                        if slt(add(calldatasize(), not(3)), 160) { revert(0, 0) }
                        let value := calldataload(4)
                        let value_1 := 0
                        value_1 := calldataload(68)
                        if iszero(eq(value_1, iszero(iszero(value_1)))) { revert(0, 0) }
                        let offset_1 := calldataload(100)
                        if gt(offset_1, 0xffffffffffffffff) { revert(0, 0) }
                        let value3_1, value4_1 := abi_decode_array_bytes32_dyn_calldata(add(4, offset_1), calldatasize())
                        let offset_2 := calldataload(132)
                        if gt(offset_2, 0xffffffffffffffff) { revert(0, 0) }
                        let value5, value6 := abi_decode_bytes_calldata(add(4, offset_2), calldatasize())
                        let expr := fun_getCurrentTier()
                        let expr_1 := 0x02)
                        let diff := add(expr_1, not(0))
                        if gt(diff, expr_1)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0, 36)
                        }
                        if lt(expr, diff)
                        {
                            require_helper_stringliteral( caller()))
                        }
                        let _3 := sload( 0x03)
                        let expr_2 := checked_add_uint256( value)
                        let ret := 0
                        ret := 0x016f44a83aab6c233c000000
                        _2 := 0
                        if 0x0ce969ea1006cd3d1c000000)
                        {
                            let memPtr := mload(64)
                            mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr, 4), 32)
                            mstore(add(memPtr, 36), 22)
                            mstore(add(memPtr, 68), "Exceeds bonding supply")
                            revert(memPtr, 100)
                        }
                        let var := value))
                        if calldataload(36))
                        {
                            let memPtr_1 := mload(64)
                            mstore(memPtr_1, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_1, 4), 32)
                            mstore(add(memPtr_1, 36), 17)
                            mstore(add(memPtr_1, 68), "Slippage exceeded")
                            revert(memPtr_1, 100)
                        }
                        if var)
                        {
                            let memPtr_2 := mload(64)
                            mstore(memPtr_2, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_2, 4), 32)
                            mstore(add(memPtr_2, 36), 21)
                            mstore(add(memPtr_2, 68), "Insufficient ETH sent")
                            revert(memPtr_2, 100)
                        }
                        let expr_3 := 0
                        switch value_1
                        case 0 {
                            expr_3 := 0
                        }
                        default {
                            expr_3 := caller())
                        }
                        if expr_3
                        {
                            fun_setSkipNFT( caller())
                        }
                        fun_transfer( value)
                        sstore( value))
                        sstore(4, var))
                        if iszero(iszero(value6))
                        {
                            require_helper_stringliteral_d80e( 0xffffffffffffffff)))
                            let var_1 := 0
                            let expr_4 := 0
                            expr_4 := 1
                            var_1 := 0x01fffffffffffffffe), 0x01fffffffffffffffe)), expr_4)
                            let memPtr_3 := mload(64)
                            finalize_allocation_38723(memPtr_3)
                            mstore(memPtr_3, caller())
                            let _4 := add(memPtr_3, 32)
                            mstore(_4, and(var_1, 0xffffffffffffffffffffffff))
                            let _mpos := calldatasize())
                            let _5 := add(memPtr_3, 64)
                            mstore(_5, _mpos)
                            let _6 := sload( 0x0a)
                            sstore( 0x0a, increment_uint256(_6))
                            mstore( _6)
                            mstore(32, 0x09)
                            let dataSlot := keccak256( 64)
                            sstore(dataSlot, or(and(sload(dataSlot), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), and(and(mload(memPtr_3), 0xffffffffffffffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffffffffffffffff)))
                            update_storage_value_offsett_uint96_to_uint96(dataSlot, and(mload(_4), 0xffffffffffffffffffffffff))
                            let memberSlot := add(dataSlot, expr_4)
                            let _7 := mload(_5)
                            let newLen := mload(_7)
                            if gt(newLen, 0xffffffffffffffff)
                            {
                                mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                                mstore(4, 0x41)
                                revert( 36)
                            }
                            let _8 := extract_byte_array_length(sload(memberSlot))
                            if gt(_8, 31)
                            {
                                mstore( memberSlot)
                                let data := keccak256( 32)
                                let deleteStart := add(data, shr(5, add(newLen, 31)))
                                if lt(newLen, 32) { deleteStart := data }
                                let _9 := add(data, shr(5, add(_8, 31)))
                                let start := deleteStart
                                for { } lt(start, _9) { start := add(start, expr_4) }
                                {
                                    sstore(start, 0)
                                }
                            }
                            let srcOffset := 0
                            srcOffset := 32
                            switch gt(newLen, 31)
                            case 1 {
                                let loopEnd := and(newLen, not(31))
                                mstore( memberSlot)
                                let dstPtr := keccak256( srcOffset)
                                let i := 0
                                for { } lt(i, loopEnd) { i := add(i, 32) }
                                {
                                    sstore(dstPtr, mload(add(_7, srcOffset)))
                                    dstPtr := add(dstPtr, expr_4)
                                    srcOffset := add(srcOffset, 32)
                                }
                                if lt(loopEnd, newLen)
                                {
                                    let lastValue := mload(add(_7, srcOffset))
                                    sstore(dstPtr, and(lastValue, not(shr(and(shl( newLen), 248), not(0)))))
                                }
                                sstore(memberSlot, add(shl(expr_4, newLen), expr_4))
                            }
                            default {
                                let value_2 := 0
                                if newLen
                                {
                                    value_2 := mload(add(_7, srcOffset))
                                }
                                sstore(memberSlot, or(and(value_2, not(shr(shl( newLen), not(0)))), shl(expr_4, newLen)))
                            }
                        }
                        if expr_3
                        {
                            fun__setSkipNFT( caller())
                        }
                        if var)
                        {
                            fun_safeTransferETH( var))
                        }
                        return( 0, 0)
                    }
                    case 0x18160ddd {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _10 := shr(160, sload( 0xa20d6e21d0e5255308))
                        let memPos_4 := mload(64)
                        mstore(memPos_4, _10)
                        return(memPos_4, 32)
                    }
                    case 0x183e9519 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        mstore(_2, calldataload(4))
                        mstore(32, 9)
                        let dataSlot_1 := keccak256(_2, 64)
                        let _11 := sload( dataSlot_1)
                        let ret_mpos := copy_array_from_storage_to_memory_string(add(dataSlot_1, 1))
                        let memPos_5 := mload(64)
                        mstore(memPos_5, and(_11, 0xffffffffffffffffffffffffffffffffffffffff))
                        mstore(add(memPos_5, 32), shr(160, _11))
                        mstore(add(memPos_5, 64), 96)
                        return(memPos_5, sub(abi_encode_string(ret_mpos, add(memPos_5, 96)), memPos_5))
                    }
                    case 0x23b872dd {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 96) { revert(_2, _2) }
                        let value0_1 := abi_decode_address()
                        let value1 := abi_decode_address_38719()
                        let value_3 := calldataload(68)
                        let expr_5 := checked_sub_uint256(value_3, fun_beforeTransfer(value0_1, value1, value_3))
                        fun_processTaxes(value0_1, value1)
                        if iszero(iszero(expr_5))
                        {
                            fun_transfer(value0_1, expr_5)
                        }
                        let _12 := checked_sub_uint256(value_3, expr_5)
                        let expr_slot := fun_ref_38727(value0_1, caller())
                        let expr_6 := 0x22d473030f116ddee9f6b43ac78ba3)
                        if expr_6
                        {
                            expr_6 := 4))
                        }
                        let expr_7 := _2
                        switch expr_6
                        case 0 {
                            expr_7 := expr_slot)
                        }
                        default {
                            expr_7 := not(0)
                        }
                        if not(0)))
                        {
                            if gt(_12, expr_7)
                            {
                                mstore( _2, 0x13be252b)
                                revert(0x1c, 4)
                            }
                            sstore(expr_slot, sub( expr_7, _12))
                        }
                        fun_transfer(value0_1, value1, _12)
                        let memPos_6 := mload(64)
                        mstore(memPos_6, 1)
                        return(memPos_6, 32)
                    }
                    case 0x274e430b {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let ret_1 := fun_getSkipNFT(abi_decode_address())
                        let memPos_7 := mload(64)
                        mstore(memPos_7, iszero(iszero(ret_1)))
                        return(memPos_7, 32)
                    }
                    case 0x285b13e8 {
                        if slt(add(calldatasize(), not(3)), 64) { revert(_2, _2) }
                        let value_4 := _2
                        value_4 := calldataload(4)
                        let _13 := and(value_4, 0xffffffffffffffffffffffffffffffff)
                        if iszero(eq(value_4, _13)) { revert(_2, _2) }
                        let value_5 := _2
                        value_5 := calldataload(36)
                        let _14 := and(value_5, 0xffffffffffffffffffffffffffffffff)
                        if iszero(eq(value_5, _14)) { revert(_2, _2) }
                        let _15 := mload(64)
                        mstore(_15, 0x6352211e00000000000000000000000000000000000000000000000000000000)
                        mstore( 0x0256)
                        let _16 := staticcall(gas(), 32)
                        if iszero(_16)
                        {
                            let pos := mload(64)
                            returndatacopy(pos, _2, returndatasize())
                            revert(pos, returndatasize())
                        }
                        let expr_8 := _2
                        if _16
                        {
                            let _17 := 32
                            if gt( returndatasize()) { _17 := returndatasize() }
                            finalize_allocation(_15, _17)
                            expr_8 := abi_decode_address_fromMemory(_15, add(_15, _17))
                        }
                        if iszero( caller()))
                        {
                            let memPtr_4 := mload(64)
                            mstore(memPtr_4, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_4, 4), 32)
                            mstore(add(memPtr_4, 36), 24)
                            mstore(add(memPtr_4, 68), "Not operator token owner")
                            revert(memPtr_4, 100)
                        }
                        let _18 := iszero( _13)
                        let expr_9 := iszero(_18)
                        if _18
                        {
                            expr_9 := _14))
                        }
                        if iszero(expr_9)
                        {
                            let memPtr_5 := mload(64)
                            mstore(memPtr_5, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_5, 4), 32)
                            mstore(add(memPtr_5, 36), 42)
                            mstore(add(memPtr_5, 68), "Amount0Max and amount1Max cannot")
                            mstore(add(memPtr_5, 100), " both be 0")
                            revert(memPtr_5, 132)
                        }
                        let _19 := sload( 0x06)
                        let memPtr_6 := mload(64)
                        let newFreePtr := add(memPtr_6, 128)
                        if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr_6))
                        {
                            mstore(_2, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore(4, 0x41)
                            revert(_2, 36)
                        }
                        mstore(64, newFreePtr)
                        mstore(memPtr_6, _19)
                        let _20 := add(memPtr_6, 32)
                        mstore(_20, caller())
                        let _21 := add(memPtr_6, 64)
                        mstore(_21, _13)
                        let _22 := add(memPtr_6, 96)
                        mstore(_22, _14)
                        let _23 := mload(64)
                        mstore(_23, 0xfc6f786500000000000000000000000000000000000000000000000000000000)
                        mstore( 4), mload(memPtr_6))
                        mstore(add( 36), and(mload(_20), 0xffffffffffffffffffffffffffffffffffffffff))
                        mstore(add( 68), and(mload(_21), 0xffffffffffffffffffffffffffffffff))
                        mstore(add( 100), and(mload(_22), 0xffffffffffffffffffffffffffffffff))
                        let _24 := call(gas(), 64)
                        if iszero(_24)
                        {
                            let pos_1 := mload(64)
                            returndatacopy(pos_1, _2, returndatasize())
                            revert(pos_1, returndatasize())
                        }
                        let expr_component := _2
                        let expr_component_1 := _2
                        if _24
                        {
                            let _25 := 64
                            if gt( returndatasize()) { _25 := returndatasize() }
                            finalize_allocation(_23, _25)
                            if slt(sub( _23), 64) { revert(_2, _2) }
                            let value_6 := mload(_23)
                            let value_7 := mload(add(_23, 32))
                            expr_component := value_6
                            expr_component_1 := value_7
                        }
                        let _26 := mload(64)
                        mstore(_26, expr_component)
                        mstore(add(_26, 32), expr_component_1)
                        log2(_26, caller())
                        let memPos_8 := mload(64)
                        mstore(memPos_8, expr_component)
                        mstore(add(memPos_8, 32), expr_component_1)
                        return(memPos_8, 64)
                    }
                    case 0x28ebcda1 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let ret_2 := _2
                        ret_2 := 0x016f44a83aab6c233c000000
                        let memPos_9 := mload(64)
                        mstore(memPos_9, ret_2)
                        return(memPos_9, 32)
                    }
                    case 0x2a6a935d {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let value_8 := _2
                        value_8 := calldataload(4)
                        let _27 := iszero(value_8)
                        let _28 := iszero(_27)
                        if iszero(eq(value_8, _28)) { revert(_2, _2) }
                        let _29 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728( caller())
                        let _30 := shr(88, sload( _29))
                        mstore( _28)
                        log2( caller())
                        update_storage_value_offsett_uint8_to_uint8(_29, and(_30, 0xff))))
                        let memPos_10 := mload(64)
                        mstore(memPos_10, 1)
                        return(memPos_10, 32)
                    }
                    case 0x2f09fd2b {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_11 := mload(64)
                        mstore(memPos_11, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_11, 32)
                    }
                    case 0x313ce567 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_12 := mload(64)
                        mstore(memPos_12, 0x12)
                        return(memPos_12, 32)
                    }
                    case 0x3212082a {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let value_9 := calldataload(4)
                        if iszero( 0x0a)))
                        {
                            let memPtr_7 := mload(64)
                            mstore(memPtr_7, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_7, 4), 32)
                            mstore(add(memPtr_7, 36), 22)
                            mstore(add(memPtr_7, 68), "Message does not exist")
                            revert(memPtr_7, 100)
                        }
                        mstore(_2, value_9)
                        mstore(32, 0x09)
                        let dataSlot_2 := keccak256(_2, 64)
                        let memPtr_8 := mload(64)
                        finalize_allocation_38723(memPtr_8)
                        let _31 := sload(dataSlot_2)
                        mstore(memPtr_8, and(_31, 0xffffffffffffffffffffffffffffffffffffffff))
                        let _32 := add(memPtr_8, 32)
                        mstore(_32, shr(160, _31))
                        let memberValue := copy_array_from_storage_to_memory_string(add(dataSlot_2, 1))
                        mstore(add(memPtr_8, 64), memberValue)
                        let expr_component_2, expr_component_3, expr_component_4 := fun_unpackData( 0xffffffffffffffffffffffff))
                        let cleaned := and(mload( 0xffffffffffffffffffffffffffffffffffffffff)
                        let memPos_13 := mload(64)
                        mstore(memPos_13, cleaned)
                        mstore(add(memPos_13, 32), and(expr_component_2, 0xffffffff))
                        mstore(add(memPos_13, 64), and(expr_component_3, 0xffffffffffffffff))
                        mstore(add(memPos_13, 96), iszero(iszero(expr_component_4)))
                        mstore(add(memPos_13, 128), 160)
                        return(memPos_13, sub(abi_encode_string(memberValue, add(memPos_13, 160)), memPos_13))
                    }
                    case 0x32cb6b0c {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_14 := mload(64)
                        mstore(memPos_14, 0x0e58ae924ab2396058000000)
                        return(memPos_14, 32)
                    }
                    case 0x3fc8cef3 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_15 := mload(64)
                        mstore(memPos_15, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_15, 32)
                    }
                    case 0x4086bf89 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _33 := loadimmutable("7799")
                        let sum := add(_33, 0x0fd200)
                        if gt(_33, sum)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0x24)
                        }
                        if sum)
                        {
                            let memPtr_9 := mload(64)
                            mstore(memPtr_9, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_9, 4), 32)
                            mstore(add(memPtr_9, 36), 34)
                            mstore(add(memPtr_9, 68), "Too early for liquidity deployme")
                            mstore(add(memPtr_9, 100), "nt")
                            revert(memPtr_9, 132)
                        }
                        if iszero( 0xffffffffffffffffffffffffffffffffffffffff)))
                        {
                            let memPtr_10 := mload(64)
                            mstore(memPtr_10, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_10, 4), 32)
                            mstore(add(memPtr_10, 36), 26)
                            mstore(add(memPtr_10, 68), "Liquidity already deployed")
                            revert(memPtr_10, 100)
                        }
                        let expr_10 := selfbalance()
                        if iszero(expr_10)
                        {
                            let memPtr_11 := mload(64)
                            mstore(memPtr_11, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_11, 4), 32)
                            mstore(add(memPtr_11, 36), 16)
                            mstore(add(memPtr_11, 68), "No ETH to deploy")
                            revert(memPtr_11, 100)
                        }
                        let _34 := sload( 0x03)
                        let diff_1 := sub( _34)
                        if gt(diff_1, 0x0e58ae924ab2396058000000)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0x24)
                        }
                        if _34)
                        {
                            let memPtr_12 := mload(64)
                            mstore(memPtr_12, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_12, 4), 32)
                            mstore(add(memPtr_12, 36), 19)
                            mstore(add(memPtr_12, 68), "No tokens to deploy")
                            revert(memPtr_12, 100)
                        }
                        let _35 := mload(64)
                        mstore(_35, 0xc9c6539600000000000000000000000000000000000000000000000000000000)
                        mstore( address())
                        mstore(add( 0xffffffffffffffffffffffffffffffffffffffff))
                        let _36 := call(gas(), 32)
                        if iszero(_36)
                        {
                            let pos_2 := mload(64)
                            returndatacopy(pos_2, _2, returndatasize())
                            revert(pos_2, returndatasize())
                        }
                        let expr_11 := _2
                        if _36
                        {
                            let _37 := 32
                            if gt( returndatasize()) { _37 := returndatasize() }
                            finalize_allocation(_35, _37)
                            expr_11 := abi_decode_address_fromMemory(_35, add(_35, _37))
                        }
                        sstore( 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), and(expr_11, 0xffffffffffffffffffffffffffffffffffffffff)))
                        let diff_2 := add(expr_10, not(0x2386f26fc0ffff))
                        if gt(diff_2, expr_10)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( _2, 36)
                        }
                        let _38 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                        fun_approve( _38, diff_1)
                        let _39 := mload(64)
                        mstore(_39, 0xf305d71900000000000000000000000000000000000000000000000000000000)
                        mstore( address())
                        mstore(add( 36), diff_1)
                        mstore(add( _2)
                        mstore(add( 100), _2)
                        mstore(add( address())
                        mstore(add( timestamp())
                        let _40 := call(gas(), _38, diff_2, _39, 196, _39, 96)
                        if iszero(_40)
                        {
                            let pos_3 := mload(64)
                            returndatacopy(pos_3, _2, returndatasize())
                            revert(pos_3, returndatasize())
                        }
                        let expr_component_5 := _2
                        let expr_component_6 := _2
                        let expr_component_7 := _2
                        if _40
                        {
                            let _41 := 96
                            if gt( returndatasize()) { _41 := returndatasize() }
                            finalize_allocation(_39, _41)
                            if slt(sub( _39), 96) { revert(_2, _2) }
                            let value_10 := mload(_39)
                            let value_11 := mload(add(_39, 32))
                            let value_12 := mload(add(_39, 64))
                            expr_component_5 := value_10
                            expr_component_6 := value_11
                            expr_component_7 := value_12
                        }
                        pop(fun_initializeCultPoolLogic())
                        let memPos_16 := mload(64)
                        mstore(memPos_16, expr_component_5)
                        mstore(add(memPos_16, 32), expr_component_6)
                        mstore(add(memPos_16, 64), expr_component_7)
                        return(memPos_16, 96)
                    }
                    case 0x46ca626b {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_17 := mload(64)
                        mstore(memPos_17, 0x3c)
                        return(memPos_17, 32)
                    }
                    case 0x4af18f4f {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let _42 := sload( 0x03)
                        let var_2 := _42, calldataload(4)))
                        let memPos_18 := mload(64)
                        mstore(memPos_18, var_2)
                        return(memPos_18, 32)
                    }
                    case 0x4ef41efc {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let cleaned_1 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                        let memPos_19 := mload(64)
                        mstore(memPos_19, cleaned_1)
                        return(memPos_19, 32)
                    }
                    case 0x50a08606 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _43 := sload( 6)
                        let memPos_20 := mload(64)
                        mstore(memPos_20, _43)
                        return(memPos_20, 32)
                    }
                    case 0x5e21afa3 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 64) { revert(_2, _2) }
                        let value_13 := calldataload(4)
                        let value_14 := calldataload(36)
                        if lt(value_14, value_13)
                        {
                            let memPtr_13 := mload(64)
                            mstore(memPtr_13, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_13, 4), 32)
                            mstore(add(memPtr_13, 36), 13)
                            mstore(add(memPtr_13, 68), "Invalid range")
                            revert(memPtr_13, 100)
                        }
                        if iszero( 0x0a)))
                        {
                            let memPtr_14 := mload(64)
                            mstore(memPtr_14, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_14, 4), 32)
                            mstore(add(memPtr_14, 36), 17)
                            mstore(add(memPtr_14, 68), "End out of bounds")
                            revert(memPtr_14, 100)
                        }
                        let expr_12 := checked_sub_uint256(value_14, value_13)
                        let sum_1 := add(expr_12, 1)
                        if gt(expr_12, sum_1)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( _2, 36)
                        }
                        let memPtr_15 := _2
                        let _44 := array_allocation_size_array_address_dyn(sum_1)
                        let memPtr_16 := mload(64)
                        finalize_allocation(memPtr_16, _44)
                        mstore(memPtr_16, sum_1)
                        memPtr_15 := memPtr_16
                        calldatacopy(add(memPtr_16, 32), calldatasize(), add(array_allocation_size_array_address_dyn(sum_1), not(31)))
                        let _45 := array_allocation_size_array_address_dyn(sum_1)
                        let memPtr_17 := mload(64)
                        finalize_allocation(memPtr_17, _45)
                        mstore(memPtr_17, sum_1)
                        let dataSize := array_allocation_size_array_address_dyn(sum_1)
                        let dataStart := add(memPtr_17, 32)
                        calldatacopy(dataStart, calldatasize(), add(dataSize, not(31)))
                        let _46 := array_allocation_size_array_address_dyn(sum_1)
                        let memPtr_18 := mload(64)
                        finalize_allocation(memPtr_18, _46)
                        mstore(memPtr_18, sum_1)
                        let dataSize_1 := array_allocation_size_array_address_dyn(sum_1)
                        let dataStart_1 := add(memPtr_18, 32)
                        calldatacopy(dataStart_1, calldatasize(), add(dataSize_1, not(31)))
                        let _47 := array_allocation_size_array_address_dyn(sum_1)
                        let memPtr_19 := mload(64)
                        finalize_allocation(memPtr_19, _47)
                        mstore(memPtr_19, sum_1)
                        let dataSize_2 := array_allocation_size_array_address_dyn(sum_1)
                        let dataStart_2 := add(memPtr_19, 32)
                        calldatacopy(dataStart_2, calldatasize(), add(dataSize_2, not(31)))
                        let _48 := array_allocation_size_array_address_dyn(sum_1)
                        let memPtr_20 := mload(64)
                        finalize_allocation(memPtr_20, _48)
                        mstore(memPtr_20, sum_1)
                        let _49 := add(array_allocation_size_array_address_dyn(sum_1), not(31))
                        let i_1 := _2
                        for { } lt(i_1, _49) { i_1 := add(i_1, 32) }
                        {
                            mstore(add(add(memPtr_20, i_1), 32), 96)
                        }
                        let var_i := _2
                        for { } lt(var_i, sum_1)
                        {
                            var_i := 1)
                        }
                        {
                            mstore(_2, checked_add_uint256(value_13, var_i))
                            mstore(32, 0x09)
                            let dataSlot_3 := keccak256(_2, 64)
                            let memPtr_21 := mload(64)
                            finalize_allocation_38723(memPtr_21)
                            let _50 := sload(dataSlot_3)
                            mstore(memPtr_21, and(_50, 0xffffffffffffffffffffffffffffffffffffffff))
                            let _51 := add(memPtr_21, 32)
                            mstore(_51, shr(160, _50))
                            let memberValue_1 := copy_array_from_storage_to_memory_string(add(dataSlot_3, 1))
                            let _52 := add(memPtr_21, 64)
                            mstore(_52, memberValue_1)
                            mstore( 0xffffffffffffffffffffffffffffffffffffffff))
                            let expr_component_8, expr_component_9, expr_component_10 := fun_unpackData( 0xffffffffffffffffffffffff))
                            let _53 := memory_array_index_access_address_dyn(memPtr_19, var_i)
                            mstore(_53, iszero(iszero(expr_component_10)))
                            let _54 := memory_array_index_access_address_dyn(memPtr_18, var_i)
                            mstore(_54, and(expr_component_9, 0xffffffffffffffff))
                            let _55 := memory_array_index_access_address_dyn(memPtr_17, var_i)
                            mstore(_55, and(expr_component_8, 0xffffffff))
                            mstore(memory_array_index_access_address_dyn(memPtr_20, var_i), mload(_52))
                            pop(memory_array_index_access_address_dyn(memPtr_20, var_i))
                        }
                        let memPos_21 := mload(64)
                        mstore(memPos_21, 160)
                        let tail := abi_encode_array_address_dyn(memPtr_16, add(memPos_21, 160))
                        mstore(add(memPos_21, 32), sub(tail, memPos_21))
                        let pos_4 := tail
                        let length := mload(memPtr_17)
                        mstore(tail, length)
                        pos_4 := add(tail, 32)
                        let srcPtr := dataStart
                        let i_2 := _2
                        for { } lt(i_2, length) { i_2 := add(i_2, 1) }
                        {
                            mstore(pos_4, and(mload(srcPtr), 0xffffffff))
                            pos_4 := add(pos_4, 32)
                            srcPtr := add(srcPtr, 32)
                        }
                        mstore(add(memPos_21, 64), sub(pos_4, memPos_21))
                        let pos_5 := pos_4
                        let length_1 := mload(memPtr_18)
                        mstore(pos_4, length_1)
                        pos_5 := add(pos_4, 32)
                        let srcPtr_1 := dataStart_1
                        let i_3 := _2
                        for { } lt(i_3, length_1) { i_3 := add(i_3, 1) }
                        {
                            mstore(pos_5, and(mload(srcPtr_1), 0xffffffffffffffff))
                            pos_5 := add(pos_5, 32)
                            srcPtr_1 := add(srcPtr_1, 32)
                        }
                        mstore(add(memPos_21, 96), sub(pos_5, memPos_21))
                        let pos_6 := pos_5
                        let length_2 := mload(memPtr_19)
                        mstore(pos_5, length_2)
                        pos_6 := add(pos_5, 32)
                        let srcPtr_2 := dataStart_2
                        let i_4 := _2
                        for { } lt(i_4, length_2) { i_4 := add(i_4, 1) }
                        {
                            mstore(pos_6, iszero(iszero(mload(srcPtr_2))))
                            pos_6 := add(pos_6, 32)
                            srcPtr_2 := add(srcPtr_2, 32)
                        }
                        mstore(add(memPos_21, 128), sub(pos_6, memPos_21))
                        let pos_7 := pos_6
                        let length_3 := mload(memPtr_20)
                        mstore(pos_6, length_3)
                        pos_7 := add(pos_6, 32)
                        let tail_1 := add(add(pos_6, shl(5, length_3)), 32)
                        let srcPtr_3 := add(memPtr_20, 32)
                        let i_5 := _2
                        for { } lt(i_5, length_3) { i_5 := add(i_5, 1) }
                        {
                            mstore(pos_7, add(sub(tail_1, pos_6), not(31)))
                            tail_1 := abi_encode_string(mload(srcPtr_3), tail_1)
                            srcPtr_3 := add(srcPtr_3, 32)
                            pos_7 := add(pos_7, 32)
                        }
                        return(memPos_21, sub(tail_1, memPos_21))
                    }
                    case 0x66d46aa0 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let value_15 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                        let memPos_22 := mload(64)
                        mstore(memPos_22, value_15)
                        return(memPos_22, 32)
                    }
                    case 0x70a08231 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let value0_2 := abi_decode_address()
                        let var_3 := _2
                        var_3 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(value0_2)))
                        let memPos_23 := mload(64)
                        mstore(memPos_23, var_3)
                        return(memPos_23, 32)
                    }
                    case 0x70ab41ad {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_24 := mload(64)
                        mstore(memPos_24, 0xc5dc95539589fbd24be07c6c14eca4)
                        return(memPos_24, 32)
                    }
                    case 0x71d58b47 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 128) { revert(_2, _2) }
                        let value_16 := calldataload(4)
                        let offset_3 := calldataload(68)
                        if gt(offset_3, 0xffffffffffffffff) { revert(_2, _2) }
                        let value2, value3_2 := abi_decode_array_bytes32_dyn_calldata(add(4, offset_3), calldatasize())
                        let offset_4 := calldataload(100)
                        if gt(offset_4, 0xffffffffffffffff) { revert(_2, _2) }
                        let value4_2, value5_1 := abi_decode_bytes_calldata(add(4, offset_4), calldatasize())
                        let expr_13 := fun_getCurrentTier()
                        let expr_14 := 0x02)
                        let diff_3 := add(expr_14, not(0))
                        if gt(diff_3, expr_14)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( _2, 36)
                        }
                        if lt(expr_13, diff_3)
                        {
                            require_helper_stringliteral( caller()))
                        }
                        let var_4 := _2
                        var_4 := caller())))
                        if lt(var_4, value_16)
                        {
                            let memPtr_22 := mload(64)
                            mstore(memPtr_22, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_22, 4), 32)
                            mstore(add(memPtr_22, 36), 20)
                            mstore(add(memPtr_22, 68), "Insufficient balance")
                            revert(memPtr_22, 100)
                        }
                        let _56 := sload( 0x03)
                        let expr_15 := fun_calculateIntegral( _56)
                        let expr_16 := calldataload(36)))
                        if expr_16
                        {
                            expr_16 := expr_15))
                        }
                        if iszero(expr_16)
                        {
                            let memPtr_23 := mload(64)
                            mstore(memPtr_23, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_23, 4), 32)
                            mstore(add(memPtr_23, 36), 14)
                            mstore(add(memPtr_23, 68), "Invalid refund")
                            revert(memPtr_23, 100)
                        }
                        fun_transfer( value_16)
                        sstore( value_16))
                        sstore(4, expr_15))
                        if iszero(iszero(value5_1))
                        {
                            require_helper_stringliteral_d80e( 0xffffffffffffffff)))
                            let var_5 := _2
                            let var_isBuy := _2
                            let expr_17 := or( 0x01fffffffffffffffe), 0x01fffffffffffffffe))
                            let expr_18 := _2
                            var_isBuy := _2
                            expr_18 := _2
                            var_5 := expr_17
                            let memPtr_24 := mload(64)
                            finalize_allocation_38723(memPtr_24)
                            mstore(memPtr_24, caller())
                            let _57 := add(memPtr_24, 32)
                            mstore(_57, expr_17)
                            let _mpos_1 := calldatasize())
                            let _58 := add(memPtr_24, 64)
                            mstore(_58, _mpos_1)
                            let _59 := sload( 0x0a)
                            sstore( 0x0a, increment_uint256(_59))
                            mstore(_2, _59)
                            mstore(32, 0x09)
                            let dataSlot_4 := keccak256(_2, 64)
                            sstore(dataSlot_4, or(and(sload(dataSlot_4), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), and(and(mload(memPtr_24), 0xffffffffffffffffffffffffffffffffffffffff), 0xffffffffffffffffffffffffffffffffffffffff)))
                            update_storage_value_offsett_uint96_to_uint96(dataSlot_4, and(mload(_57), 0xffffffffffffffffffffffff))
                            let memberSlot_1 := add(dataSlot_4, 1)
                            let _60 := mload(_58)
                            let newLen_1 := mload(_60)
                            if gt(newLen_1, 0xffffffffffffffff)
                            {
                                mstore(_2, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                                mstore(4, 0x41)
                                revert(_2, 36)
                            }
                            let _61 := extract_byte_array_length(sload(memberSlot_1))
                            if gt(_61, 31)
                            {
                                mstore(_2, memberSlot_1)
                                let data_1 := keccak256(_2, 32)
                                let deleteStart_1 := add(data_1, shr(5, add(newLen_1, 31)))
                                if lt(newLen_1, 32) { deleteStart_1 := data_1 }
                                let _62 := add(data_1, shr(5, add(_61, 31)))
                                let start_1 := deleteStart_1
                                for { } lt(start_1, _62) { start_1 := add(start_1, 1) }
                                { sstore(start_1, _2) }
                            }
                            let srcOffset_1 := _2
                            srcOffset_1 := 32
                            switch gt(newLen_1, 31)
                            case 1 {
                                let loopEnd_1 := and(newLen_1, not(31))
                                mstore(_2, memberSlot_1)
                                let dstPtr_1 := keccak256(_2, srcOffset_1)
                                let i_6 := _2
                                for { } lt(i_6, loopEnd_1) { i_6 := add(i_6, 32) }
                                {
                                    sstore(dstPtr_1, mload(add(_60, srcOffset_1)))
                                    dstPtr_1 := add(dstPtr_1, 1)
                                    srcOffset_1 := add(srcOffset_1, 32)
                                }
                                if lt(loopEnd_1, newLen_1)
                                {
                                    let lastValue_1 := mload(add(_60, srcOffset_1))
                                    sstore(dstPtr_1, and(lastValue_1, not(shr(and(shl( newLen_1), 248), not(0)))))
                                }
                                sstore(memberSlot_1, add(shl(1, newLen_1), 1))
                            }
                            default {
                                let value_17 := _2
                                if newLen_1
                                {
                                    value_17 := mload(add(_60, srcOffset_1))
                                }
                                sstore(memberSlot_1, or(and(value_17, not(shr(shl( newLen_1), not(0)))), shl(1, newLen_1)))
                            }
                        }
                        let product := mul(expr_15, 0x2580)
                        let _63 := iszero(expr_15)
                        if iszero(or(_63, eq( div(product, expr_15))))
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( _2, 36)
                        }
                        let _64 := mload(64)
                        mstore(_64, 0x6352211e00000000000000000000000000000000000000000000000000000000)
                        mstore( 0x0256)
                        let _65 := staticcall(gas(), 32)
                        if iszero(_65)
                        {
                            let pos_8 := mload(64)
                            returndatacopy(pos_8, _2, returndatasize())
                            revert(pos_8, returndatasize())
                        }
                        let expr_19 := _2
                        if _65
                        {
                            let _66 := 32
                            if gt( returndatasize()) { _66 := returndatasize() }
                            finalize_allocation(_64, _66)
                            expr_19 := abi_decode_address_fromMemory(_64, add(_64, _66))
                        }
                        let product_1 := mul(expr_15, 100)
                        if iszero(or(_63, eq( div(product_1, expr_15))))
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( _2, 36)
                        }
                        fun_safeTransferETH(expr_19, 0x2710))
                        fun_safeTransferETH( 0x2710))
                        return(_2, _2)
                    }
                    case 0x7412c223 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let ret_3 := fun_getCurrentTier()
                        let memPos_25 := mload(64)
                        mstore(memPos_25, ret_3)
                        return(memPos_25, 32)
                    }
                    case 0x791b98bc {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_26 := mload(64)
                        mstore(memPos_26, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_26, 32)
                    }
                    case 0x7c5e2795 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_27 := mload(64)
                        mstore(memPos_27, 0x58d15e17628000)
                        return(memPos_27, 32)
                    }
                    case 0x808a5457 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let value_18 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                        let memPos_28 := mload(64)
                        mstore(memPos_28, value_18)
                        return(memPos_28, 32)
                    }
                    case 0x83f170be {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_29 := mload(64)
                        mstore(memPos_29, 0x0190)
                        return(memPos_29, 32)
                    }
                    case 0x951166c0 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _67 := sload( 10)
                        let memPos_30 := mload(64)
                        mstore(memPos_30, _67)
                        return(memPos_30, 32)
                    }
                    case 0x95d89b41 { external_fun_name() }
                    case 0x9871164a {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_31 := mload(64)
                        mstore(memPos_31, 0x1b1ae4d6e2ef500000)
                        return(memPos_31, 32)
                    }
                    case 0xa9059cbb {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 64) { revert(_2, _2) }
                        let value0_3 := abi_decode_address()
                        let value_19 := calldataload(36)
                        let expr_20 := checked_sub_uint256(value_19, value0_3, value_19))
                        fun_processTaxes( value0_3)
                        if iszero(iszero(expr_20))
                        {
                            fun_transfer( expr_20)
                        }
                        fun_transfer( value0_3, checked_sub_uint256(value_19, expr_20))
                        let memPos_32 := mload(64)
                        mstore(memPos_32, 1)
                        return(memPos_32, 32)
                    }
                    case 0xbd5d1a4f {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_33 := mload(64)
                        mstore(memPos_33, 0x3635c9adc5dea00000)
                        return(memPos_33, 32)
                    }
                    case 0xc0de74b1 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let value_20 := calldataload(4)
                        if iszero(lt(value_20, 2)))
                        {
                            revert( _2, _2)
                        }
                        let slot, offset_5 := storage_array_index_access_bytes32_dyn(value_20)
                        let value_21 := shr(shl(3, offset_5), sload( slot))
                        let memPos_34 := mload(64)
                        mstore(memPos_34, value_21)
                        return(memPos_34, 32)
                    }
                    case 0xc45a0155 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_35 := mload(64)
                        mstore(memPos_35, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_35, 32)
                    }
                    case 0xcd3293de {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _68 := sload(4)
                        let memPos_36 := mload(64)
                        mstore(memPos_36, _68)
                        return(memPos_36, 32)
                    }
                    case 0xd240245a {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        mstore(_2, calldataload(4))
                        mstore(32, 8)
                        let _69 := sload(keccak256(_2, 64))
                        let memPos_37 := mload(64)
                        mstore(memPos_37, _69)
                        return(memPos_37, 32)
                    }
                    case 0xd8380fb5 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _70 := sload( 3)
                        let memPos_38 := mload(64)
                        mstore(memPos_38, _70)
                        return(memPos_38, 32)
                    }
                    case 0xdd1b9c4a {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_39 := mload(64)
                        mstore(memPos_39, 0x2710)
                        return(memPos_39, 32)
                    }
                    case 0xdd321ac4 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let value_22 := calldataload(4)
                        let _71 := sload( caller()))
                        let r := _2
                        let _72 := _2
                        _72 := _2
                        r := div( 0xd3c21bcecceda1000000)
                        if and(shr(128, _71), 0xffffffff)))
                        {
                            let memPtr_25 := mload(64)
                            mstore(memPtr_25, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_25, 4), 32)
                            mstore(add(memPtr_25, 36), 47)
                            mstore(add(memPtr_25, 68), "Cannot mint more NFTs than token")
                            mstore(add(memPtr_25, 100), " balance allows")
                            revert(memPtr_25, 132)
                        }
                        let expr_21 := fun_getSkipNFT( caller())
                        if expr_21
                        {
                            fun_setSkipNFT( caller())
                        }
                        let product_2 := _2
                        product_2 := mul(value_22, 0xd3c21bcecceda1000000)
                        if iszero(or(iszero(value_22), eq( div(product_2, value_22))))
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0x24)
                        }
                        fun_transfer( product_2)
                        if expr_21
                        {
                            fun__setSkipNFT( caller())
                        }
                        return(_2, _2)
                    }
                    case 0xdd62ed3e {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 64) { revert(_2, _2) }
                        let value0_4 := abi_decode_address()
                        let ret_4 := fun_allowance(value0_4, abi_decode_address_38719())
                        let memPos_40 := mload(64)
                        mstore(memPos_40, ret_4)
                        return(memPos_40, 32)
                    }
                    case 0xdebefaa6 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 64) { revert(_2, _2) }
                        let offset_6 := calldataload(4)
                        if gt(offset_6, 0xffffffffffffffff) { revert(_2, _2) }
                        let value0_5, value1_1 := abi_decode_array_bytes32_dyn_calldata(add(4, offset_6), calldatasize())
                        let ret_5 := fun_isWhitelisted(value0_5, value1_1, abi_decode_address_38719())
                        let memPos_41 := mload(64)
                        mstore(memPos_41, iszero(iszero(ret_5)))
                        return(memPos_41, 32)
                    }
                    case 0xe1726a50 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let value_23 := and(sload(_2), 0xffffffffffffffffffffffffffffffffffffffff)
                        let memPos_42 := mload(64)
                        mstore(memPos_42, value_23)
                        return(memPos_42, 32)
                    }
                    case 0xe7572230 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), 32) { revert(_2, _2) }
                        let r_1 := div( 0xd3c21bcecceda1000000)
                        let product_3 := mul(r_1, 0x0de0b6b3a7640000)
                        if iszero(or(iszero(r_1), eq( div(product_3, r_1))))
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0x24)
                        }
                        let expr_22 := fun_mulWad( product_3)
                        if gt( expr_22))
                        {
                            if expr_22
                            {
                                mstore( 0xbac65e5b)
                                revert(0x1c, 4)
                            }
                        }
                        let _73 := fun_mulWad(product_3, product_3)
                        if gt( _73))
                        {
                            if _73
                            {
                                mstore( 0xbac65e5b)
                                revert(0x1c, 4)
                            }
                        }
                        if gt( product_3))
                        {
                            if product_3
                            {
                                mstore( 0xbac65e5b)
                                revert(0x1c, 4)
                            }
                        }
                        let sum_2 := add( 0x0de0b6b3a7640000))
                        if gt( sum_2)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore( 0x11)
                            revert( 0x24)
                        }
                        let var_6 := 0x0de0b6b3a7640000))
                        let memPos_43 := mload(64)
                        mstore(memPos_43, var_6)
                        return(memPos_43, 32)
                    }
                    case 0xf887ea40 {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let memPos_44 := mload(64)
                        mstore(memPos_44, and( 0xffffffffffffffffffffffffffffffffffffffff))
                        return(memPos_44, 32)
                    }
                    case 0xfcca68e7 {
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        if iszero( fun_initializeCultPoolLogic())
                        {
                            let memPtr_26 := mload(64)
                            mstore(memPtr_26, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore(add(memPtr_26, 4), 32)
                            mstore(add(memPtr_26, 36), 26)
                            mstore(add(memPtr_26, 68), "Pool initialization failed")
                            revert(memPtr_26, 100)
                        }
                        return(_2, _2)
                    }
                    case 0xfdab463d {
                        if callvalue() { revert(_2, _2) }
                        if slt(add(calldatasize(), not(3)), _2) { revert(_2, _2) }
                        let _74, _75 := storage_array_index_access_bytes32_dyn( fun_getCurrentTier())
                        let value_24 := shr(shl(3, _75), sload( _74))
                        let memPos_45 := mload(64)
                        mstore(memPos_45, value_24)
                        return(memPos_45, 32)
                    }
                }
                if iszero(calldatasize()) { stop() }
                let result := shr( 0x00))
                if 0xe5eb36c8)
                {
                    let cleaned_2 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                    if cleaned_2))
                    {
                        mstore( 0xce5a776b)
                        revert(0x1c, 4)
                    }
                    let _76 := and( 4), 0xffffffffffffffffffffffffffffffffffffffff)
                    let _77 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                    let expr_23 := 0x44)
                    let _78 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                    if _77)
                    {
                        mstore( 0xea553b34)
                        revert(0x1c, 4)
                    }
                    if iszero(cleaned_2)
                    {
                        mstore( 0x40739bf0)
                        revert(0x1c, 4)
                    }
                    let var_7 := 0x00
                    var_7 := not(0)))
                    if 0xffffffffffffffffffffffffffffffffffffffff)))
                    {
                        mstore( 0xa1148100)
                        revert(0x1c, 4)
                    }
                    if iszero(eq(_78, _76))
                    {
                        if fun_ref(_76, _78)))
                        {
                            if _78))
                            {
                                mstore( 0x59c896be)
                                revert(0x1c, 4)
                            }
                        }
                    }
                    let _79 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(_76)
                    let _80 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(_77)
                    let _81 := shr(160, sload( _79))
                    if _81)
                    {
                        mstore( 0xf4d678b8)
                        revert(0x1c, 4)
                    }
                    update_storage_value_offsett_uint96_to_uint96(_79, not(0xd3c21bcecceda0ffffff)), 0xffffffffffffffffffffffff))
                    update_storage_value_offsett_uint96_to_uint96(_80, 0xffffffffffffffffffffffff))
                    if fun__get(expr_23)
                    {
                        fun_set(expr_23)
                        mstore( expr_23)
                        mstore(0x20, 0xa20d6e21d0e525530c)
                        let dataSlot_5 := keccak256( 64)
                        sstore(dataSlot_5, and(sload(dataSlot_5), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000))
                    }
                    let _82 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(_76)
                    let ret_6 := and(add(and(shr(128, sload( 0xffffffff), not(0)), 0xffffffff)
                    update_storage_value_offsett_uint32_to_uint32(_79, ret_6)
                    let expr_24 := fun_get(_82, ret_6)
                    let var_8 := 0x00
                    var_8 := 1)
                    let expr_25 := fun_get_38750( var_8)
                    fun__set(_82, expr_24)
                    let var_ := 0x00
                    var_ := 1)
                    let usr$s := add(0xa20d6e21d0e5255312000000000000000000000000, shr(3, var_))
                    let usr$o := and(shl(5, var_), 0xe0)
                    let usr$v := sload(usr$s)
                    sstore(usr$s, xor(usr$v, shl(usr$o, and( xor(expr_25, shr(usr$o, usr$v))))))
                    let value_25 := and(shr(128, sload( 0xffffffff)
                    update_storage_value_offsett_uint32_to_uint32(_80, 0xffffffff))
                    let _83 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(_77)
                    fun__set(_83, 0xffffffff))
                    fun_setOwnerAliasAndOwnedIndex(expr_23, value_25)
                    mstore( 0xd3c21bcecceda1000000)
                    log3( 0x20, 100389287136786176327247604509743168900146139575972864366142685224231313322991, _76, _77)
                    mstore( 1)
                    return( 0x20)
                }
                if 0xf6916ddd)
                {
                    if 0xffffffffffffffffffffffffffffffffffffffff)))
                    {
                        mstore( 0xce5a776b)
                        revert(0x1c, 4)
                    }
                    sstore( 0x24))))
                    mstore( 1)
                    return( 0x20)
                }
                if 0x62fb246d)
                {
                    mstore( 0xffffffffffffffffffffffffffffffffffffffff))))))
                    return( 0x20)
                }
                if 0x2d8a746e)
                {
                    let _84 := calldataload( 4)
                    if 0xffffffffffffffffffffffffffffffffffffffff))
                    {
                        mstore( 0xceea21b6)
                        revert(0x1c, 4)
                    }
                    mstore( 0xffffffffffffffffffffffffffffffffffffffff))
                    return( 0x20)
                }
                if 0xc016aa52)
                {
                    mstore( 4)), 0xffffffffffffffffffffffffffffffffffffffff))
                    return( 0x20)
                }
                if 0xd10b6e0c)
                {
                    if 0xffffffffffffffffffffffffffffffffffffffff)))
                    {
                        mstore( 0xce5a776b)
                        revert(0x1c, 4)
                    }
                    let _85 := and( 4), 0xffffffffffffffffffffffffffffffffffffffff)
                    let expr_26 := 0x24)
                    let _86 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                    let var_9 := 0x00
                    var_9 := not(0)))
                    let cleaned_3 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                    if _86, cleaned_3))
                    {
                        if fun_ref(cleaned_3, _86)))
                        {
                            mstore( 0xcfb3b942)
                            revert(0x1c, 4)
                        }
                    }
                    mstore( expr_26)
                    mstore(0x20, 0xa20d6e21d0e525530c)
                    let dataSlot_6 := keccak256( 64)
                    sstore( 0xffffffffffffffffffffffffffffffffffffffff)))
                    let usr$s_1 := add(0xa20d6e21d0e525530d000000000000000000000000, shr(8, expr_26))
                    let usr$o_1 := and(0xff, expr_26)
                    sstore(usr$s_1, or(and(sload(usr$s_1), not(shl(usr$o_1, _85)))))
                    mstore( cleaned_3)
                    return( 0x20)
                }
                if 0x27ef5495)
                {
                    mstore( 4)), 0xffffffffffffffffffffffffffffffffffffffff))
                    return( 0x20)
                }
                if 0xf5b100ea)
                {
                    mstore( 4), 0xffffffffffffffffffffffffffffffffffffffff)))), 0xffffffff))
                    return( 0x20)
                }
                if 0xe2c79281)
                {
                    mstore( 0xffffffff))
                    return( 0x20)
                }
                if 0xcb30b460)
                {
                    mstore( 0x20))
                    let size := 0x00
                    let _87 := 0x00
                    _87 := 0x00
                    size := 64
                    let memPtr_27 := mload(64)
                    finalize_allocation(memPtr_27, 64)
                    mstore(memPtr_27, 27)
                    mstore(add(memPtr_27, "https://example.com/token/1")
                    let usr$o_2 := add(memPtr_27, not(31))
                    mstore(add(memPtr_27, 59), 0x00)
                    mstore(usr$o_2, 0x20)
                    return(usr$o_2, 96)
                }
                if 0xb7a94eb8)
                {
                    mstore( 0x01)
                    return( 0x20)
                }
                mstore( 0x3c10b94e)
                revert(0x1c, 4)
            }
            function abi_encode_string(value, pos) -> end
            {
                let length := mload(value)
                mstore(pos, length)
                mcopy(add(pos, 0x20), add(value, 0x20), length)
                mstore(add(add(pos, length), 0x20), 0)
                end := add(add(pos, and(add(length, 31), not(31))), 0x20)
            }
            function external_fun_name()
            {
                if callvalue() { revert(0, 0) }
                if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                let size := 0
                let _1 := 0
                _1 := 0
                size := 64
                let memPtr := mload(64)
                finalize_allocation(memPtr, 64)
                mstore(memPtr, 7)
                mstore(add(memPtr, 32), "TEST404")
                let memPos := mload(64)
                mstore(memPos, 32)
                return(memPos, sub(abi_encode_string(memPtr, add(memPos, 32)), memPos))
            }
            function abi_decode_address() -> value
            {
                value := calldataload(4)
                if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
            }
            function abi_decode_address_38719() -> value
            {
                value := calldataload(36)
                if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
            }
            function abi_decode_bytes_calldata(offset, end) -> arrayPos, length
            {
                if iszero(slt(add(offset, 0x1f), end)) { revert(0, 0) }
                length := calldataload(offset)
                if gt(length, 0xffffffffffffffff) { revert(0, 0) }
                arrayPos := add(offset, 0x20)
                if gt(add(add(offset, length), 0x20), end) { revert(0, 0) }
            }
            function abi_decode_array_bytes32_dyn_calldata(offset, end) -> arrayPos, length
            {
                if iszero(slt(add(offset, 0x1f), end)) { revert(0, 0) }
                length := calldataload(offset)
                if gt(length, 0xffffffffffffffff) { revert(0, 0) }
                arrayPos := add(offset, 0x20)
                if gt(add(add(offset, shl(5, length)), 0x20), end) { revert(0, 0) }
            }
            function extract_byte_array_length(data) -> length
            {
                length := shr(1, data)
                let outOfPlaceEncoding := and(data, 1)
                if iszero(outOfPlaceEncoding) { length := and(length, 0x7f) }
                if eq(outOfPlaceEncoding, lt(length, 32))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x22)
                    revert(0, 0x24)
                }
            }
            function finalize_allocation_38723(memPtr)
            {
                let newFreePtr := add(memPtr, 96)
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert( 0x24)
                }
                mstore(64, newFreePtr)
            }
            function finalize_allocation_38963(memPtr)
            {
                let newFreePtr := add(memPtr, 160)
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert( 0x24)
                }
                mstore(64, newFreePtr)
            }
            function finalize_allocation(memPtr, size)
            {
                let newFreePtr := add(memPtr, and(add(size, 31), not(31)))
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert( 0x24)
                }
                mstore(64, newFreePtr)
            }
            function copy_array_from_storage_to_memory_string(slot) -> memPtr
            {
                memPtr := mload(64)
                let ret := 0
                let slotValue := sload(slot)
                let length := extract_byte_array_length(slotValue)
                mstore(memPtr, length)
                switch and(slotValue, 1)
                case 0 {
                    mstore(add(memPtr, 0x20), and(slotValue, not(255)))
                    ret := add(add(memPtr, shl(5, iszero(iszero(length)))), 0x20)
                }
                case 1 {
                    mstore( slot)
                    let dataPos := keccak256( 0x20)
                    let i := 0
                    for { } lt(i, length) { i := add(i, 0x20) }
                    {
                        mstore(add(add(memPtr, i), 0x20), sload(dataPos))
                        dataPos := add(dataPos, 1)
                    }
                    ret := add(add(memPtr, i), 0x20)
                }
                finalize_allocation(memPtr, sub(ret, memPtr))
            }
            function checked_mul_uint256(x, y) -> product
            {
                product := mul(x, y)
                if iszero(or(iszero(x), eq(y, div(product, x))))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
            }
            function abi_encode_array_address_dyn(value, pos) -> end
            {
                let length := mload(value)
                mstore(pos, length)
                pos := add(pos, 0x20)
                let srcPtr := add(value, 0x20)
                let i := 0
                for { } lt(i, length) { i := add(i, 1) }
                {
                    mstore(pos, and(mload(srcPtr), 0xffffffffffffffffffffffffffffffffffffffff))
                    pos := add(pos, 0x20)
                    srcPtr := add(srcPtr, 0x20)
                }
                end := pos
            }
            function storage_array_index_access_bytes32_dyn(index) -> slot, offset
            {
                if iszero(lt(index, sload( 2)))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x32)
                    revert(0, 0x24)
                }
                mstore( 2)
                slot := add(keccak256( 0x20), index)
                offset := 0
            }
            function array_allocation_size_string(length) -> size
            {
                if gt(length, 0xffffffffffffffff)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert(0, 0x24)
                }
                size := add(and(add(length, 31), not(31)), 0x20)
            }
            function checked_sub_uint256(x, y) -> diff
            {
                diff := sub(x, y)
                if gt(diff, x)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
            }
            function require_helper_stringliteral(condition)
            {
                if iszero(condition)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    mstore(add(memPtr, 4), 32)
                    mstore(add(memPtr, 36), 15)
                    mstore(add(memPtr, 68), "Not whitelisted")
                    revert(memPtr, 100)
                }
            }
            function checked_add_uint256(x, y) -> sum
            {
                sum := add(x, y)
                if gt(x, sum)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
            }
            function require_helper_stringliteral_d80e(condition)
            {
                if iszero(condition)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    mstore(add(memPtr, 4), 32)
                    mstore(add(memPtr, 36), 36)
                    mstore(add(memPtr, 68), "Amount too large for message sto")
                    mstore(add(memPtr, 100), "rage")
                    revert(memPtr, 132)
                }
            }
            function abi_decode_available_length_string(src, length, end) -> array
            {
                let _1 := array_allocation_size_string(length)
                let memPtr := mload(64)
                finalize_allocation(memPtr, _1)
                array := memPtr
                mstore(memPtr, length)
                if gt(add(src, length), end)
                {
                    revert( 0, 0)
                }
                calldatacopy(add(memPtr, 0x20), src, length)
                mstore(add(add(memPtr, length), 0x20), 0)
            }
            function increment_uint256(value) -> ret
            {
                if eq(value, not(0))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
                ret := add(value, 1)
            }
            function update_storage_value_offsett_uint96_to_uint96(slot, value)
            {
                let _1 := sload(slot)
                sstore(slot, or(and(_1, 0xffffffffffffffffffffffffffffffffffffffff), and(shl(160, value), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000)))
            }
            function mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(key) -> dataSlot
            {
                mstore(0, and(key, 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(0x20, 0xa20d6e21d0e5255313)
                dataSlot := keccak256(0, 0x40)
            }
            function mapping_index_access_mapping_address_struct_AddressData_storage_of_address(key) -> dataSlot
            {
                mstore(0, and(key, 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(0x20, 0xa20d6e21d0e5255310)
                dataSlot := keccak256(0, 0x40)
            }
            function fun_getSkipNFT(var_owner) -> var_result
            {
                let _1 := shr(88, sload( mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_owner)))
                var_result := 0x02)))
                if 0x01))
                {
                    var_result := 0x01
                }
            }
            function abi_decode_address_fromMemory(headStart, dataEnd) -> value0
            {
                if slt(sub(dataEnd, headStart), 32) { revert(0, 0) }
                let value := mload(headStart)
                if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff)))
                {
                    revert( 0, 0)
                }
                value0 := value
            }
            function array_allocation_size_array_address_dyn(length) -> size
            {
                if gt(length, 0xffffffffffffffff)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert(0, 0x24)
                }
                size := add(shl(5, length), 0x20)
            }
            function memory_array_index_access_address_dyn(baseRef, index) -> addr
            {
                if iszero(lt(index, mload(baseRef)))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x32)
                    revert(0, 0x24)
                }
                addr := add(add(baseRef, shl(5, index)), 32)
            }
            function fun_getCurrentTier() -> var
            {
                var := 0
                let _1 := loadimmutable("7799")
                if _1)
                {
                    var := 0
                    leave
                }
                let r := div( 0x015180)
                let _2 := sload( 0x02)
                let expr := 0
                switch iszero(lt(r, _2))
                case 0 { expr := r }
                default {
                    let diff := add(_2, not(0))
                    if gt(diff, _2)
                    {
                        mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                        mstore(4, 0x11)
                        revert( 0x24)
                    }
                    expr := diff
                }
                var := expr
            }
            function fun_allowance(var_owner, var_spender) -> var
            {
                var := 0
                if 0x22d473030f116ddee9f6b43ac78ba3)
                {
                    if 0x04))
                    {
                        var := not(0)
                        leave
                    }
                }
                var := fun_ref_38727(var_owner, var_spender))
            }
            function fun_isWhitelisted(var_proof_offset, var_proof_length, var_account) -> var
            {
                let _1, _2 := storage_array_index_access_bytes32_dyn( fun_getCurrentTier())
                let value := shr(shl(3, _2), sload( _1))
                let expr_8081_mpos := mload(64)
                let _3 := add(expr_8081_mpos, 0x20)
                mstore(_3, and(shl(96, var_account), not(0xffffffffffffffffffffffff)))
                mstore(expr_8081_mpos, 20)
                finalize_allocation(expr_8081_mpos, 52)
                let _4 := keccak256( expr_8081_mpos))
                let _5 := array_allocation_size_array_address_dyn(var_proof_length)
                let memPtr := mload(64)
                finalize_allocation(memPtr, _5)
                let dst := memPtr
                mstore(memPtr, var_proof_length)
                dst := add(memPtr, 0x20)
                let dst_1 := dst
                let srcEnd := add(var_proof_offset, shl(5, var_proof_length))
                if gt(srcEnd, calldatasize())
                {
                    revert( 0, 0)
                }
                let src := var_proof_offset
                for { }
                lt(src, srcEnd)
                {
                    src := add(src, 0x20)
                }
                {
                    mstore(dst, calldataload(src))
                    dst := add(dst, 0x20)
                }
                let var_leaf := _4
                let _6 := mload(memPtr)
                if _6
                {
                    let usr$offset := dst_1
                    let usr$end := add(add(memPtr, shl( 0x20)
                    for { } 1 { }
                    {
                        let usr$scratch := shl( gt(var_leaf, mload(usr$offset)))
                        mstore(usr$scratch, var_leaf)
                        mstore(xor(usr$scratch, mload(usr$offset))
                        var_leaf := keccak256( 64)
                        usr$offset := add(usr$offset, 0x20)
                        if iszero(lt(usr$offset, usr$end)) { break }
                    }
                }
                var := eq(var_leaf, value)
            }
            function update_storage_value_offsett_uint8_to_uint8(slot, value)
            {
                let _1 := sload(slot)
                sstore(slot, or(and(_1, not(0xff0000000000000000000000)), and(shl(88, value), 0xff0000000000000000000000)))
            }
            function fun_approve(var_owner, var_spender, var_amount)
            {
                let cleaned := and(var_spender, 0xffffffffffffffffffffffffffffffffffffffff)
                if 0x22d473030f116ddee9f6b43ac78ba3)
                {
                    let _1 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_owner)
                    update_storage_value_offsett_uint8_to_uint8(_1, or( 0x04))
                }
                sstore( var_amount)
                mstore( var_amount)
                log3( cleaned)
            }
            function fun_setSkipNFT(var_owner)
            {
                let _1 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_owner)
                let _2 := shr(88, sload( _1))
                mstore( 0, 0)
                log2( 0x20, 82154622030720576933762060765127571295570445401790869870495469274293849949075, and(var_owner, 0xffffffffffffffffffffffffffffffffffffffff))
                update_storage_value_offsett_uint8_to_uint8(_1, and(_2, 0xff))))
            }
            function fun__setSkipNFT(var_owner)
            {
                let _1 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_owner)
                let _2 := shr(88, sload( _1))
                mstore( 0x01)
                log2( 0x20, 82154622030720576933762060765127571295570445401790869870495469274293849949075, and(var_owner, 0xffffffffffffffffffffffffffffffffffffffff))
                update_storage_value_offsett_uint8_to_uint8(_1, and(_2, 0xff))))
            }
            function update_storage_value_offsett_uint32_to_uint32(slot, value)
            {
                let _1 := sload(slot)
                sstore(slot, or(and(_1, 0xffffffffffffffffffffffff00000000ffffffffffffffffffffffffffffffff), and(shl(128, value), 0xffffffff00000000000000000000000000000000)))
            }
            function fun_transfer(var_from, var_to, var_amount)
            {
                if 0xffffffffffffffffffffffffffffffffffffffff))
                {
                    mstore( 0xea553b34)
                    revert(0x1c, 0x04)
                }
                let _1 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_from)
                let _2 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address_38728(var_to)
                if 0xffffffffffffffffffffffffffffffffffffffff))
                {
                    mstore( 0x40739bf0)
                    revert(0x1c, 0x04)
                }
                let memPtr := mload(64)
                let newFreePtr := add(memPtr, 384)
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert( 0x24)
                }
                mstore(64, newFreePtr)
                mstore(memPtr, 0x00)
                mstore(add(memPtr, 32), 0x00)
                mstore(add(memPtr, 128), 0x00)
                mstore(add(memPtr, 160), 0x00)
                mstore(add(memPtr, 192), 0x00)
                mstore(add(memPtr, 224), 0x00)
                mstore(add(memPtr, 256), 0x00)
                mstore(add(memPtr, 288), 0x00)
                mstore(add(memPtr, 320), 0x00)
                mstore(add(memPtr, 352), 0x00)
                let _3 := sload( _1)
                mstore(add(memPtr, 64), and(shr(128, _3), 0xffffffff))
                mstore(add(memPtr, 96), and(shr(128, sload( 0xffffffff))
                let _4 := shr(160, _3)
                if gt(var_amount, _4)
                {
                    mstore( 0xf4d678b8)
                    revert(0x1c, 0x04)
                }
                let expr := _4, var_amount)
                update_storage_value_offsett_uint96_to_uint96(_1, 0xffffffffffffffffffffffff))
                let sum := add(shr(160, sload( var_amount)
                update_storage_value_offsett_uint96_to_uint96(_2, 0xffffffffffffffffffffffff))
                let _5 := mload(add(memPtr, 64))
                let r := 0x00
                let _6 := 0x00
                _6 := 0x00
                r := div(expr, 0xd3c21bcecceda1000000)
                mstore(memPtr, mul(gt(_5, r), sub(_5, r)))
                if fun_getSkipNFT(var_to))
                {
                    if 0xffffffffffffffffffffffffffffffffffffffff))
                    {
                        let _7 := mload(add(memPtr, 64))
                        mstore(add(memPtr, 96), sub(_7, mload( memPtr)))
                    }
                    let r_1 := 0x00
                    let _8 := 0x00
                    _8 := 0x00
                    r_1 := div(sum, 0xd3c21bcecceda1000000)
                    let _9 := mload(add(memPtr, 96))
                    mstore(add(memPtr, 32), mul(gt(r_1, _9), sub(r_1, _9)))
                }
                for { } iszero(0x00)
                { }
                {
                    let _10 := mload(add(memPtr, 64))
                    let _11 := mload( memPtr)
                    let _12 := mload(add(memPtr, 32))
                    let var_z := xor(_11, mul(xor(_11, _12), lt(_12, _11)))
                    if _10, mul(xor(_10, var_z), lt(var_z, _10)))
                    {
                        break
                    }
                    mstore(memPtr, sub(_11, xor(_10, mul(xor(_10, var_z), lt(var_z, _10)))))
                    mstore(add(memPtr, 32), sub(_12, xor(_10, mul(xor(_10, var_z), lt(var_z, _10)))))
                    if 0xffffffffffffffffffffffffffffffffffffffff))
                    {
                        mstore(add(memPtr, 96), add(mload(add(memPtr, 96)), xor(_10, mul(xor(_10, var_z), lt(var_z, _10)))))
                        break
                    }
                    let var_p := mload( 64)
                    mstore(add(var_p, 0x144027d3)
                    mstore(add(var_p, 0xffffffffffffffffffffffffffffffffffffffff))
                    mstore(add(var_p, 0xffffffffffffffffffffffffffffffffffffffff))
                    mstore(add(var_p, 160), 96)
                    let usr$logs := add(var_p, 192)
                    mstore(usr$logs, xor(_10, mul(xor(_10, var_z), lt(var_z, _10))))
                    mstore( 224))
                    mstore(add( var_p), usr$logs)
                    mstore(var_p, add(var_p, 224))
                    mstore(add(memPtr, 320), var_p)
                    let _13 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(var_from)
                    let _14 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(var_to)
                    mstore(add(memPtr, 224), and( 0xffffffff))
                    let var_toIndex := mload(add(memPtr, 96))
                    let expr_1 := xor(_10, mul(xor(_10, var_z), lt(var_z, _10))))
                    let _15 := 1
                    for { } 1
                    { }
                    {
                        if iszero(_15)
                        {
                            var_toIndex := 1)
                            if eq(var_toIndex, expr_1) { break }
                        }
                        _15 := 0
                        let ret := add(mload(add(memPtr, 64)), not(0))
                        mstore(add(memPtr, 64), ret)
                        let cleaned := and( 0xffffffff)
                        fun__set(_14, var_toIndex, cleaned)
                        let cleaned_1 := and(mload(add(memPtr, 224)), 0xffffffff)
                        fun_setOwnerAliasAndOwnedIndex(cleaned, cleaned_1, 0xffffffff))
                        let _16 := mload(add(memPtr, 320))
                        let usr$offset := mload(_16)
                        mstore(usr$offset, cleaned)
                        mstore(_16, add(usr$offset, 32))
                        if fun__get(cleaned)
                        {
                            fun_set(cleaned)
                            mstore( cleaned)
                            mstore(32, 0xa20d6e21d0e525530c)
                            let dataSlot := keccak256( 64)
                            sstore(dataSlot, and(sload(dataSlot), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000))
                        }
                    }
                    mstore(add(memPtr, 96), var_toIndex)
                    update_storage_value_offsett_uint32_to_uint32(_2, 0xffffffff))
                    update_storage_value_offsett_uint32_to_uint32(_1, and(mload(add(memPtr, 64)), 0xffffffff))
                    break
                }
                let _17 := sload( 0xa20d6e21d0e5255308)
                let _18 := mload(add(memPtr, 32))
                let _19 := mload( memPtr)
                let diff := sub(add(and(shr(128, _17), 0xffffffff), _18), _19)
                mstore(add(memPtr, 128), diff)
                let result := or(and(_17, 0xffffffffffffffffffffffff00000000ffffffffffffffffffffffffffffffff), and(shl(128, diff), 0xffffffff00000000000000000000000000000000))
                sstore( result)
                let sum_1 := add(_19, _18)
                let var_p_1 := mload( 64)
                let usr$logs_1 := add(var_p_1, 160)
                mstore(usr$logs_1, sum_1)
                mstore( 192))
                mstore(add( var_p_1), usr$logs_1)
                mstore(var_p_1, add(var_p_1, 192))
                mstore(add(memPtr, 352), var_p_1)
                mstore(add(memPtr, 288), and(shr(96, result), 0xffffffff))
                if memPtr)))
                {
                    mstore(add(var_p_1, 1))
                    let _20 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(var_from)
                    let var_fromIndex := mload(add(memPtr, 64))
                    let diff_1 := sub(var_fromIndex, mload( memPtr))
                    mstore(add(memPtr, 160), diff_1)
                    update_storage_value_offsett_uint32_to_uint32(_1, 0xffffffff))
                    let _21 := 1
                    for { } 1
                    { }
                    {
                        if iszero(_21)
                        {
                            if eq(var_fromIndex, mload(add(memPtr, 160)))
                            { break }
                        }
                        _21 := 0x00
                        var_fromIndex := not(0))
                        let _22 := fun_get(_20, var_fromIndex)
                        let cleaned_2 := and(_22, 0xffffffff)
                        let usr$i := add(cleaned_2, not(0))
                        let usr$s := add(0xa20d6e21d0e5255312000000000000000000000000, shr(2, usr$i))
                        let usr$v := sload(usr$s)
                        let usr$o := and(shl(6, usr$i), 192)
                        sstore(usr$s, xor(usr$v, shl(usr$o, and( shr(usr$o, usr$v)))))
                        fun_packedLogsAppend( cleaned_2)
                        let usr$s_1 := add(0xa20d6e21d0e525530e000000000000000000000000, and(shr( 16777215))
                        sstore(usr$s_1, and(sload(usr$s_1), not(shl(and( 1))))
                        if fun__get(cleaned_2)
                        {
                            fun_set(cleaned_2)
                            mstore( cleaned_2)
                            mstore(32, 0xa20d6e21d0e525530c)
                            let dataSlot_1 := keccak256( 64)
                            sstore(dataSlot_1, and(sload(dataSlot_1), 0xffffffffffffffffffffffff0000000000000000000000000000000000000000))
                        }
                    }
                }
                if mload(add(memPtr, 32))))
                {
                    let _23 := mload(add(memPtr, 352))
                    mstore(add(_23, var_to))
                    let _24 := mapping_index_access_mapping_address_struct_AddressData_storage_of_address(var_to)
                    mstore(add(memPtr, 224), and( 0xffffffff))
                    let _25 := sload( 0xa20d6e21d0e5255308)
                    let r_2 := 0x00
                    let _26 := 0x00
                    _26 := 0x00
                    r_2 := div( 0xd3c21bcecceda1000000)
                    let value := and(shr(32, _25), 0xffffffff)
                    let var_result := 0x00
                    let _27 := gt(value, r_2)
                    var_result := or(mul(iszero(_27), value), _27)
                    mstore(add(memPtr, 256), var_result)
                    let var_toIndex_1 := mload(add(memPtr, 96))
                    let sum_2 := add(var_toIndex_1, mload(add(memPtr, 32)))
                    mstore(add(memPtr, 192), sum_2)
                    update_storage_value_offsett_uint32_to_uint32(_2, 0xffffffff))
                    let var_burnedPoolHead := 0xffffffff)
                    let _28 := 1
                    for { } 1
                    { }
                    {
                        if iszero(_28)
                        {
                            if eq(var_toIndex_1, mload(add(memPtr, 192)))
                            { break }
                        }
                        _28 := 0x00
                        let var_id := 0x00
                        switch 0xffffffff), and(mload(add(memPtr, 288)), 0xffffffff)))
                        case 0 {
                            var_id := mload(add(memPtr, 256))
                            for { } 1
                            { }
                            {
                                let var := 0x00
                                var := not(0)))
                                if iszero( 0xffffffff))
                                { break }
                                let var_unsetBitIndex := 0x00
                                var_unsetBitIndex := not(0)
                                let usr$bucket := add( 1)))
                                let _29 := not(sload(usr$bucket))
                                let _30 := and( 1))
                                let usr$negBits := shl(_30, shr(_30, _29))
                                if iszero(usr$negBits)
                                {
                                    for { } 1
                                    { }
                                    {
                                        usr$bucket := add(usr$bucket, 1)
                                        usr$negBits := not(sload(usr$bucket))
                                        if or(usr$negBits, gt(usr$bucket, add( r_2)))) { break }
                                    }
                                    if gt(usr$bucket, add( r_2)))
                                    {
                                        let _31 := and( not(r_2))
                                        usr$negBits := shr(_31, shl(_31, usr$negBits))
                                    }
                                }
                                if usr$negBits
                                {
                                    let usr$b := and(usr$negBits, add(not(usr$negBits), 1))
                                    let usr$r := and(shr(247, shl(and(shr(248, mul(usr$b, 0x2aaaaaaaba69a69a6db6db6db2cb2cb2ce739ce73def7bdeffffffff)), 252), 0x1412563212c14164235266736f7425221143267a45243675267677)), 480)
                                    let usr$r_1 := or(shl( 0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405)))
                                    var_unsetBitIndex := or(usr$r_1, sub( 1)))))
                                }
                                let var_result_1 := 0x00
                                let _32 := gt(var_unsetBitIndex, r_2)
                                var_result_1 := or(mul(iszero(_32), var_unsetBitIndex), _32)
                                var_id := var_result_1
                            }
                            let _33 := add( 1)
                            let var_result_2 := 0x00
                            let _34 := gt(_33, r_2)
                            var_result_2 := or(mul(iszero(_34), _33), _34)
                            mstore(add(memPtr, 256), var_result_2)
                        }
                        default {
                            let _35 := var_burnedPoolHead
                            var_burnedPoolHead := 0xffffffff)
                            let var_result_3 := 0x00
                            var_result_3 := and( 0x1fffffff)))))
                            var_id := var_result_3
                        }
                        let usr$s_2 := add(0xa20d6e21d0e525530e000000000000000000000000, shr( var_id))
                        let _36 := shl(and(0xff, var_id), 1)
                        sstore(usr$s_2, or(and(sload(usr$s_2), not(_36)), _36))
                        fun__set(_24, var_toIndex_1, 0xffffffff))
                        let cleaned_3 := and(mload(add(memPtr, 224)), 0xffffffff)
                        let _37 := var_toIndex_1
                        var_toIndex_1 := 1)
                        fun_setOwnerAliasAndOwnedIndex(var_id, cleaned_3, 0xffffffff))
                        fun_packedLogsAppend( var_id)
                    }
                    let _38 := sload( 0xa20d6e21d0e5255308)
                    sstore( or(or(and(_38, not(0xffffffffffffffff00000000)), and(shl(64, var_burnedPoolHead), 0xffffffff0000000000000000)), and(shl(32, mload(add(memPtr, 256))), 0xffffffff00000000)))
                }
                let _39 := mload(add(memPtr, 320))
                if iszero(iszero(_39))
                {
                    let cleaned_4 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                    let usr$logs_2 := mload(add(_39, 32))
                    let usr$n := add(0x84, shl( mload(usr$logs_2)))
                    let usr$o_1 := add(usr$logs_2, not(127))
                    if iszero(and(eq(mload(usr$o_1), 32)))
                    {
                        revert( 0x00, 0x00)
                    }
                }
                let _40 := mload(add(memPtr, 352))
                if iszero(iszero(_40))
                {
                    let cleaned_5 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                    let usr$logs_3 := mload(add(_40, 64))
                    let usr$o_2 := add(usr$logs_3, not(63))
                    mstore(usr$o_2, 0x263c69d6)
                    mstore(add(usr$logs_3, not(31)), 32)
                    if iszero(and(eq(mload(usr$o_2), 32)))
                    {
                        revert( 0x00, 0x00)
                    }
                }
                mstore( var_amount)
                log3( 0xffffffffffffffffffffffffffffffffffffffff))
            }
            function fun_safeTransferETH(var_to, var_amount)
            {
                if iszero(call(gas(), var_to, var_amount, 0x00, 0x00, codesize(), 0x00))
                {
                    mstore(0x00, 0xb12d13eb)
                    revert(0x1c, 0x04)
                }
            }
            function fun_beforeTransfer(var_from, var_to, var_amount) -> var
            {
                var := 0
                let cleaned := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                if cleaned)
                {
                    var := var_amount
                    leave
                }
                let _1 := 0xffffffffffffffffffffffffffffffffffffffff)
                let expr := address())
                if iszero(expr)
                {
                    expr := address())
                }
                if expr
                {
                    var := var_amount
                    leave
                }
                let expr_1 := cleaned)
                if iszero(expr_1)
                {
                    expr_1 := eq(_1, cleaned)
                }
                if expr_1
                {
                    let product := mul(var_amount, 0x0190)
                    if iszero(or(iszero(var_amount), eq( div(product, var_amount))))
                    {
                        mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                        mstore(4, 0x11)
                        revert( 0x24)
                    }
                    var := 0x2710))
                    leave
                }
                var := var_amount
            }
            function fun_processTaxes(var_from, var_to)
            {
                let cleaned := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                if cleaned)
                {
                    leave
                }
                let expr := address())
                if iszero(expr)
                {
                    expr := address())
                }
                if expr
                {
                    leave
                }
                let expr_1 := cleaned)
                if expr_1
                {
                    expr_1 := 0xff))
                }
                let expr_2 := expr_1
                if expr_1
                {
                    mstore( number())
                    mstore(0x20, 0x08)
                    expr_2 := 0x03)
                }
                if expr_2
                {
                    let var := 0
                    var := address())))
                    if 0x056bc75e2d63100000))
                    {
                        sstore( 0x01))
                        let expr_9325_component, expr_9325_component_1 := fun_selectOperation()
                        switch iszero(expr_9325_component)
                        case 0 {
                            switch 0x01)
                            case 0 { fun_handleAddCultLiquidity() }
                            default {
                                pop(fun_buyCultWithExactEth(expr_9325_component_1))
                            }
                        }
                        default { fun_handleSellTax() }
                        sstore( not(255)))
                        mstore( number())
                        mstore(0x20, 0x08)
                        let _1 := sload(keccak256( 0x40))
                        let sum := add(_1, 0x01)
                        if gt(_1, sum)
                        {
                            mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                            mstore(4, 0x11)
                            revert( 0x24)
                        }
                        mstore( number())
                        mstore(0x20, 0x08)
                        sstore(keccak256( 0x40), sum)
                    }
                }
            }
            function fun_unpackData(var_packed) -> var_timestamp, var_amount, var_isBuy
            {
                var_timestamp := var_packed), 0xffffffff)
                var_amount := var_packed), 0xffffffffffffffff)
                var_isBuy := 0x01), 0x01)
            }
            function abi_decode_int24_fromMemory(offset) -> value
            {
                value := mload(offset)
                if iszero(eq(value, signextend(2, value))) { revert(0, 0) }
            }
            function abi_decode_uint16_fromMemory(offset) -> value
            {
                value := mload(offset)
                if iszero(eq(value, and(value, 0xffff))) { revert(0, 0) }
            }
            function abi_decode_uint160t_int24t_uint16t_uint16t_uint16t_uint8t_bool_fromMemory(headStart, dataEnd) -> value0, value1, value2, value3, value4, value5, value6
            {
                if slt(sub(dataEnd, headStart), 224) { revert(0, 0) }
                let value := mload(headStart)
                if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff)))
                {
                    revert( 0, 0)
                }
                value0 := value
                value1 := abi_decode_int24_fromMemory(add(headStart, 32))
                value2 := abi_decode_uint16_fromMemory(add(headStart, 64))
                value3 := abi_decode_uint16_fromMemory(add(headStart, 96))
                value4 := abi_decode_uint16_fromMemory(add(headStart, 128))
                let value_1 := mload(add(headStart, 160))
                if iszero(eq(value_1, and(value_1, 0xff)))
                {
                    revert( 0, 0)
                }
                value5 := value_1
                let value_2 := mload(add(headStart, 192))
                if iszero(eq(value_2, iszero(iszero(value_2))))
                {
                    revert( 0, 0)
                }
                value6 := value_2
            }
            function checked_mul_int24(x, y) -> product
            {
                let product_raw := mul(signextend(2, x), signextend(2, y))
                product := signextend(2, product_raw)
                if iszero(eq(product, product_raw))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
            }
            function checked_div_int24(x, y) -> r
            {
                let x_1 := signextend(2, x)
                let y_1 := signextend(2, y)
                if iszero(y_1)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x12)
                    revert(0, 0x24)
                }
                if and(eq(x_1, not(8388607)), eq(y_1, not(0)))
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
                r := sdiv(x_1, y_1)
            }
            function abi_encode_address_uint256(headStart, value0, value1) -> tail
            {
                tail := add(headStart, 64)
                mstore(headStart, and(value0, 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add(headStart, 32), value1)
            }
            function extract_returndata() -> data
            {
                switch returndatasize()
                case 0 { data := 96 }
                default {
                    let _1 := returndatasize()
                    let _2 := array_allocation_size_string(_1)
                    let memPtr := mload(64)
                    finalize_allocation(memPtr, _2)
                    mstore(memPtr, _1)
                    data := memPtr
                    returndatacopy(add(memPtr, 0x20), returndatasize())
                }
            }
            function abi_decode_uint128_fromMemory(offset) -> value
            {
                value := mload(offset)
                if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffff))) { revert(0, 0) }
            }
            function return_data_selector() -> sig
            {
                if gt(returndatasize(), 3)
                {
                    returndatacopy(0, 0, 4)
                    sig := shr(224, mload(0))
                }
            }
            function try_decode_error_message() -> ret
            {
                if lt(returndatasize(), 0x44) { leave }
                let data := mload(64)
                returndatacopy(data, 4, add(returndatasize(), not(3)))
                let offset := mload(data)
                if or(gt(offset, 0xffffffffffffffff), gt(add(offset, 0x24), returndatasize())) { leave }
                let msg := add(data, offset)
                let length := mload(msg)
                if gt(length, 0xffffffffffffffff) { leave }
                if gt(add(add(msg, length), 0x20), add(add(data, returndatasize()), not(3))) { leave }
                finalize_allocation(data, add(add(offset, length), 0x20))
                ret := msg
            }
            function fun_initializeCultPoolLogic() -> var
            {
                let var_1 := 0
                var := 0
                if 0x06)))
                {
                    var := 0
                    leave
                }
                let cleaned := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                if cleaned)
                {
                    var := 0
                    leave
                }
                let _1 := mload(64)
                mstore(_1, 0x3850c7bd00000000000000000000000000000000000000000000000000000000)
                let _2 := staticcall(gas(), cleaned, _1, 4, _1, 224)
                if iszero(_2)
                {
                    let pos := mload(64)
                    returndatacopy(pos, 0, returndatasize())
                    revert(pos, returndatasize())
                }
                let expr_component := 0
                if _2
                {
                    let _3 := 224
                    if gt( returndatasize()) { _3 := returndatasize() }
                    finalize_allocation(_1, _3)
                    let expr_component_1, expr_component_2, expr_component_3, expr_component_4, expr_component_5, expr_component_6, expr_component_7 := abi_decode_uint160t_int24t_uint16t_uint16t_uint16t_uint8t_bool_fromMemory(_1, add(_1, _3))
                    expr_component := expr_component_2
                }
                let _4 := mload(64)
                mstore(_4, 0xd0c93a7c00000000000000000000000000000000000000000000000000000000)
                let _5 := staticcall(gas(), cleaned, _4, _4, 32)
                if iszero(_5)
                {
                    let pos_1 := mload(64)
                    returndatacopy(pos_1, 0, returndatasize())
                    revert(pos_1, returndatasize())
                }
                let expr := 0
                if _5
                {
                    let _6 := 32
                    if gt(32, returndatasize()) { _6 := returndatasize() }
                    finalize_allocation(_4, _6)
                    if slt(sub( 32)
                    { revert(0, 0) }
                    expr := abi_decode_int24_fromMemory(_4)
                }
                let product := 0
                let product_raw := shl( signextend(2, expr))
                product := signextend(2, product_raw)
                if iszero(eq(product, product_raw))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x11)
                    revert( 0x24)
                }
                let x := signextend(2, expr_component)
                let diff := sub(x, product)
                if or(slt(diff, not(8388607)), sgt(diff, 0x7fffff))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x11)
                    revert( 0x24)
                }
                let expr_1 := checked_mul_int24( expr)
                let sum := add(x, product)
                if or(sgt(sum, 0x7fffff), slt(sum, not(8388607)))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x11)
                    revert( 0x24)
                }
                let expr_2 := checked_mul_int24( expr)
                let expr_3 := fun_buyCultWithExactEth_38928()
                let _7 := loadimmutable("7794")
                let _8 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                if iszero(extcodesize(_8))
                {
                    revert(0, 0)
                }
                let _9 := mload(64)
                mstore(_9, 0xd0e30db000000000000000000000000000000000000000000000000000000000)
                let _10 := call(gas(), _8, 0)
                if iszero(_10)
                {
                    let pos_2 := mload(64)
                    returndatacopy(pos_2, 0, returndatasize())
                    revert(pos_2, returndatasize())
                }
                if _10
                {
                    finalize_allocation(_9, 0)
                    var_1 := 0
                }
                let _11 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                let expr_8848_mpos := mload(64)
                let _12 := add(expr_8848_mpos, 32)
                mstore(_12, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let _13 := sub(abi_encode_address_uint256(add(expr_8848_mpos, 36), _11, expr_3), expr_8848_mpos)
                mstore(expr_8848_mpos, add(_13, not(31)))
                finalize_allocation(expr_8848_mpos, _13)
                let expr_8849_component := call(gas(), var_1, var_1)
                pop(extract_returndata())
                if iszero(expr_8849_component) { revert(var_1, var_1) }
                let expr_8868_mpos := mload(64)
                let _14 := add(expr_8868_mpos, 32)
                mstore(_14, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let tail := var_1
                tail := add( 100)
                mstore( _11)
                mstore(add( 0x11c37937e08000)
                mstore(expr_8868_mpos, 68)
                finalize_allocation(expr_8868_mpos, 100)
                let expr_8869_component := call(gas(), _7, var_1, var_1)
                pop(extract_returndata())
                if iszero(expr_8869_component) { revert(var_1, var_1) }
                let memPtr := mload(64)
                let newFreePtr := add(memPtr, 352)
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x41)
                    revert( 36)
                }
                mstore(64, newFreePtr)
                mstore(memPtr, 0xc5dc95539589fbd24be07c6c14eca4)
                let _15 := add(memPtr, 32)
                mstore(_15, _8)
                let _16 := add(memPtr, 64)
                mstore(_16, 0x2710)
                let _17 := add(memPtr, 96)
                mstore(_17, signextend(2, expr_1))
                let _18 := add(memPtr, 128)
                mstore(_18, signextend(2, expr_2))
                let _19 := add(memPtr, 160)
                mstore(_19, expr_3)
                let _20 := add(memPtr, 192)
                mstore(_20, 0x11c37937e08000)
                let _21 := add(memPtr, 224)
                mstore(_21, var_1)
                let _22 := add(memPtr, 256)
                mstore(_22, var_1)
                let _23 := add(memPtr, 288)
                mstore(_23, address())
                let _24 := add(memPtr, 320)
                mstore(_24, timestamp())
                let _25 := mload(64)
                mstore(_25, 0x8831645600000000000000000000000000000000000000000000000000000000)
                mstore( and(mload(memPtr), 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add( and(mload(_15), 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add( and(mload(_16), 0xffffff))
                mstore(add( signextend(2, mload(_17)))
                mstore(add( 132), signextend(2, mload(_18)))
                mstore(add( 164), mload(_19))
                mstore(add( 196), mload(_20))
                mstore(add( 228), mload(_21))
                mstore(add( 260), mload(_22))
                mstore(add( 292), and(mload(_23), 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add( 324), mload(_24))
                let trySuccessCondition := call(gas(), _11, 128)
                let expr_component_8 := var_1
                let expr_component_9 := var_1
                if trySuccessCondition
                {
                    let _26 := 128
                    if gt( returndatasize()) { _26 := returndatasize() }
                    finalize_allocation(_25, _26)
                    if slt(sub( 128)
                    { revert(var_1, var_1) }
                    let value := mload(_25)
                    pop(abi_decode_uint128_fromMemory(add(_25, 32)))
                    let value_1 := mload(add(_25, 96))
                    expr_component_8 := value
                    expr_component_9 := value_1
                }
                switch iszero(trySuccessCondition)
                case 0 {
                    sstore( expr_component_8)
                    let diff_1 := var_1
                    diff_1 := sub( expr_component_9)
                    if gt(diff_1, 0x11c37937e08000)
                    {
                        mstore(var_1, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                        mstore( 0x11)
                        revert(var_1, 36)
                    }
                    if expr_component_9))
                    {
                        if iszero(extcodesize(_8))
                        {
                            revert(var_1, var_1)
                        }
                        let _27 := mload(64)
                        mstore(_27, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                        mstore( diff_1)
                        let _28 := call(gas(), _8, var_1)
                        if iszero(_28)
                        {
                            let pos_3 := mload(64)
                            returndatacopy(pos_3, var_1, returndatasize())
                            revert(pos_3, returndatasize())
                        }
                        if _28
                        {
                            finalize_allocation(_27, var_1)
                            if var_1 { revert(var_1, var_1) }
                        }
                    }
                    var := 0x01
                    leave
                }
                default {
                    if eq(147028384, return_data_selector())
                    {
                        if try_decode_error_message()
                        {
                            if iszero(extcodesize(_8))
                            {
                                revert(var_1, var_1)
                            }
                            let _29 := mload(64)
                            mstore(_29, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                            mstore( 0x11c37937e08000)
                            let _30 := call(gas(), _8, var_1)
                            if iszero(_30)
                            {
                                let pos_4 := mload(64)
                                returndatacopy(pos_4, var_1, returndatasize())
                                revert(pos_4, returndatasize())
                            }
                            if _30
                            {
                                finalize_allocation(_29, var_1)
                                if var_1 { revert(var_1, var_1) }
                            }
                            var := var_1
                            leave
                        }
                    }
                    let pos_5 := mload(64)
                    returndatacopy(pos_5, var_1, returndatasize())
                    revert(pos_5, returndatasize())
                }
            }
            function fun_calculateIntegral(var_lowerBound, var_upperBound) -> var
            {
                if lt(var_upperBound, var_lowerBound)
                {
                    let memPtr := mload(64)
                    mstore(memPtr, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                    mstore(add(memPtr, 4), 32)
                    mstore(add(memPtr, 36), 14)
                    mstore(add(memPtr, 68), "Invalid bounds")
                    revert(memPtr, 100)
                }
                let expr := fun_calculateIntegralFromZero(var_upperBound)
                var := fun_calculateIntegralFromZero(var_lowerBound))
            }
            function fun_ref_38727(var_a0, var_a1) -> var_ref_slot
            {
                mstore(0x28, var_a1)
                mstore(0x14, var_a0)
                mstore(0x00, 0xa20d6e21d0e525530f)
                var_ref_slot := keccak256(0x00, 0x48)
                mstore(0x28, 0x00)
            }
            function fun_ref(var_a0, var_a1) -> var_ref_slot
            {
                mstore(0x28, var_a1)
                mstore(0x14, var_a0)
                mstore(0x00, 0xa20d6e21d0e525530b)
                var_ref_slot := keccak256(0x00, 0x48)
                mstore(0x28, 0x00)
            }
            function fun_mulWad(var_x, var_y) -> var_z
            {
                if gt(var_x, div( var_y))
                {
                    if var_y
                    {
                        mstore(0, 0xbac65e5b)
                        revert(0x1c, 0x04)
                    }
                }
                var_z := div(mul(var_x, var_y), 1000000000000000000)
            }
            function mapping_index_access_mapping_uint32_address_of_uint32(key) -> dataSlot
            {
                mstore(0, and(key, 0xffffffff))
                mstore(0x20, 0xa20d6e21d0e525530a)
                dataSlot := keccak256(0, 0x40)
            }
            function fun_ownerAt(var_id) -> var
            {
                let var_1 := 0
                var_1 := not(0)))
                var := 0xffffffffffffffffffffffffffffffffffffffff)
            }
            function fun_getApproved(var_id) -> var
            {
                if 0xffffffffffffffffffffffffffffffffffffffff))
                {
                    mstore( 0xceea21b6)
                    revert(0x1c, 0x04)
                }
                mstore( var_id)
                mstore(0x20, 0xa20d6e21d0e525530c)
                var := 0x40)), 0xffffffffffffffffffffffffffffffffffffffff)
            }
            function fun_registerAndResolveAlias(var_toAddressData_slot, var_to) -> var_addressAlias
            {
                var_addressAlias := 0xffffffff)
                if var_addressAlias)
                {
                    let _1 := sload( 0xa20d6e21d0e5255308)
                    let _2 := add(and(_1, 0xffffffff), 1)
                    let ret := and(_2, 0xffffffff)
                    sstore( or(and(_1, not(0xffffffff)), ret))
                    var_addressAlias := ret
                    let _3 := sload(var_toAddressData_slot)
                    sstore(var_toAddressData_slot, or(and(_3, 0xffffffffffffffffffffffffffffffff00000000ffffffffffffffffffffffff), and(and(shl(96, _2), 0xffffffff000000000000000000000000), 0xffffffff000000000000000000000000)))
                    let _4 := mapping_index_access_mapping_uint32_address_of_uint32(ret)
                    sstore( 0xffffffffffffffffffffffffffffffffffffffff)))
                    if ret)
                    {
                        revert( 0, 0)
                    }
                }
            }
            function fun_get_38750(var_index) -> var_result
            {
                var_result := and(0xffffffff, shr(and(shl(5, var_index), 224), sload(add(0xa20d6e21d0e5255312000000000000000000000000, shr(3, var_index)))))
            }
            function fun_get(var_map_3894_slot, var_index) -> var_result
            {
                var_result := and(0xffffffff, shr(and(shl(5, var_index), 224), sload(add(shl(96, var_map_3894_slot), shr(3, var_index)))))
            }
            function fun__set(var_map_slot, var_index, var_value)
            {
                let usr$s := add(shl(96, var_map_slot), shr(3, var_index))
                let usr$o := and(shl(5, var_index), 224)
                let usr$v := sload(usr$s)
                sstore(usr$s, xor(usr$v, shl(usr$o, and(0xffffffff, xor(var_value, shr(usr$o, usr$v))))))
            }
            function fun_setOwnerAliasAndOwnedIndex(var_id, var_ownership, var_ownedIndex)
            {
                let usr$i := add(var_id, not(0))
                let usr$s := add(0xa20d6e21d0e5255312000000000000000000000000, shr(2, usr$i))
                let usr$v := sload(usr$s)
                let usr$o := and(shl(6, usr$i), 192)
                sstore(usr$s, xor(usr$v, shl(usr$o, and(0xffffffffffffffff, xor(shr(usr$o, usr$v), or(shl(32, var_ownedIndex), and(0xffffffff, var_ownership)))))))
            }
            function fun__get(var_index) -> var_result
            {
                var_result := and(1, shr(and(0xff, var_index), sload(add(0xa20d6e21d0e525530d000000000000000000000000, shr(8, var_index)))))
            }
            function fun_set(var_index)
            {
                let usr$s := add(0xa20d6e21d0e525530d000000000000000000000000, shr(8, var_index))
                sstore(usr$s, and(sload(usr$s), not(shl(and(0xff, var_index), 1))))
            }
            function fun_packedLogsAppend(var_p, var_id)
            {
                let usr$offset := mload(var_p)
                mstore(usr$offset, or(mload(add(var_p, 0x20)), shl(8, var_id)))
                mstore(var_p, add(usr$offset, 0x20))
            }
            function fun_selectOperation() -> var_operation, var_amount
            {
                let var := 0
                var := address())))
                let expr := selfbalance()
                let expr_9118_mpos := mload(64)
                let _1 := add(expr_9118_mpos, 0x20)
                mstore(_1, 0x70a0823100000000000000000000000000000000000000000000000000000000)
                mstore( address())
                mstore(expr_9118_mpos, 36)
                finalize_allocation(expr_9118_mpos, 68)
                pop(staticcall(gas(), 0, 0))
                let expr_9119_component_2_mpos := extract_returndata()
                let _2 := expr_9119_component_2_mpos)
                let headStart := add(expr_9119_component_2_mpos, 0x20)
                let value0 := 0
                if slt(sub( headStart), 32)
                {
                    revert( 0, 0)
                }
                value0 := mload(headStart)
                let expr_1 := 0x056bc75e2d63100000))
                if expr_1
                {
                    expr_1 := 0x2386f26fc10000)
                }
                if expr_1
                {
                    var_operation := 0
                    var_amount := var
                    leave
                }
                let expr_2 := 0x2386f26fc10000))
                let expr_3 := expr_2
                if expr_2
                {
                    expr_2 := 0x1b1ae4d6e2ef500000)
                }
                if expr_2
                {
                    let diff := add(expr, not(0x11c37937e07fff))
                    if gt(diff, expr)
                    {
                        mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                        mstore(4, 0x11)
                        revert( 36)
                    }
                    var_operation := 0x01
                    var_amount := diff
                    leave
                }
                let expr_4 := expr_3
                if expr_3
                {
                    expr_4 := 0x3635c9adc5dea00000))
                }
                if expr_4
                {
                    let cleaned := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                    let _3 := mload(64)
                    mstore(_3, 0x3850c7bd00000000000000000000000000000000000000000000000000000000)
                    let _4 := staticcall(gas(), cleaned, _3, 4, _3, 224)
                    if iszero(_4)
                    {
                        let pos := mload(64)
                        returndatacopy(pos, returndatasize())
                        revert(pos, returndatasize())
                    }
                    let expr_component := 0
                    if _4
                    {
                        let _5 := 224
                        if gt( returndatasize()) { _5 := returndatasize() }
                        finalize_allocation(_3, _5)
                        let expr_component_1, expr_component_2, expr_component_3, expr_component_4, expr_component_5, expr_component_6, expr_component_7 := abi_decode_uint160t_int24t_uint16t_uint16t_uint16t_uint8t_bool_fromMemory(_3, add(_3, _5))
                        expr_component := expr_component_1
                    }
                    let expr_5 := 0xffffffffffffffffffffffffffffffffffffffff)
                    let expr_6 := checked_mul_uint256(expr_5, expr_5)
                    let product := mul(expr_6, 0x0de0b6b3a7640000)
                    if iszero(or(iszero(expr_6), eq( div(product, expr_6))))
                    {
                        mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                        mstore( 0x11)
                        revert( 36)
                    }
                    let r := div( 0x0de0b6b3a7640000)
                    let expr_7 := 0
                    switch r)
                    case 0 {
                        expr_7 := value0
                    }
                    default { expr_7 := r }
                    var_operation := 0x02
                    var_amount := expr_7
                    leave
                }
                var_operation := 0
                var_amount := 0
            }
            function fun_handleAddCultLiquidity()
            {
                let expr_mpos := mload(64)
                let _1 := add(expr_mpos, 0x20)
                mstore(_1, 0x70a0823100000000000000000000000000000000000000000000000000000000)
                mstore( address())
                mstore(expr_mpos, 36)
                finalize_allocation(expr_mpos, 68)
                pop(staticcall(gas(), 0, 0))
                let expr_9722_component_2_mpos := extract_returndata()
                let _2 := expr_9722_component_2_mpos)
                let headStart := add(expr_9722_component_2_mpos, 0x20)
                let value0 := 0
                if slt(sub( headStart), 32)
                {
                    revert( 0, 0)
                }
                value0 := mload(headStart)
                let expr := selfbalance()
                let expr_1 := value0)
                if iszero(expr_1)
                {
                    expr_1 := 0x11c37937e08000)
                }
                if expr_1
                {
                    leave
                }
                let diff := add(expr, not(0x11c37937e07fff))
                if gt(diff, expr)
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert( 36)
                }
                let var_amount0 := 0
                let var_amount1 := 0
                switch 0xffffffffffffffffffffffffffffffffffffffff))
                case 0 {
                    var_amount0 := diff
                    var_amount1 := value0
                }
                default {
                    var_amount0 := value0
                    var_amount1 := diff
                }
                let cleaned := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                let _3 := mload(64)
                mstore(_3, 0x3850c7bd00000000000000000000000000000000000000000000000000000000)
                let _4 := staticcall(gas(), cleaned, _3, 224)
                if iszero(_4)
                {
                    let pos := mload(64)
                    returndatacopy(pos, returndatasize())
                    revert(pos, returndatasize())
                }
                let expr_component := 0
                if _4
                {
                    let _5 := 224
                    if gt( returndatasize()) { _5 := returndatasize() }
                    finalize_allocation(_3, _5)
                    let expr_component_1, expr_component_2, expr_component_3, expr_component_4, expr_component_5, expr_component_6, expr_component_7 := abi_decode_uint160t_int24t_uint16t_uint16t_uint16t_uint8t_bool_fromMemory(_3, add(_3, _5))
                    expr_component := expr_component_1
                }
                let expr_2 := 0xffffffffffffffffffffffffffffffffffffffff)
                let expr_3 := checked_mul_uint256(expr_2, expr_2)
                if iszero(or(iszero(expr_3), eq( expr_3))))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x11)
                    revert( 36)
                }
                let expr_4 := iszero(iszero(var_amount0))
                if expr_4
                {
                    expr_4 := 0x2386f26fc10000)
                }
                if expr_4
                {
                    pop(fun_increaseCultLiquidity(var_amount0, var_amount1))
                }
            }
            function fun_handleSellTax()
            {
                let var := 0
                var := address())))
                if 0x056bc75e2d63100000)
                {
                    leave
                }
                let memPtr := 0
                let size := 0
                let _1 := 0
                _1 := 0
                size := 96
                let memPtr_1 := mload(64)
                finalize_allocation(memPtr_1, 96)
                mstore(memPtr_1, 0x02)
                let dataStart := add(memPtr_1, 32)
                calldatacopy(dataStart, calldatasize(), add(96, not(31)))
                let addr := 0
                if iszero(mload(memPtr_1))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x32)
                    revert( 0x24)
                }
                addr := dataStart
                mstore(dataStart, address())
                let addr_1 := 0
                if iszero(lt( mload(memPtr_1)))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x32)
                    revert( 0x24)
                }
                addr_1 := add(memPtr_1, 64)
                mstore(addr_1, and( 0xffffffffffffffffffffffffffffffffffffffff))
                let _2 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                fun_approve( _2, var)
                if iszero(extcodesize(_2))
                {
                    revert( 0, 0)
                }
                let _3 := mload(64)
                mstore(_3, 0x791ac94700000000000000000000000000000000000000000000000000000000)
                mstore( var)
                mstore(add( 0)
                mstore(add( 68), 160)
                let tail := abi_encode_array_address_dyn(memPtr_1, add( 164))
                mstore(add( address())
                mstore(add( timestamp())
                let _4 := call(gas(), _2, 0)
                if iszero(_4)
                {
                    let pos := mload(64)
                    returndatacopy(pos, returndatasize())
                    revert(pos, returndatasize())
                }
                if _4
                {
                    finalize_allocation(_3, 0)
                    memPtr := 0
                }
            }
            function fun_buyCultWithExactEth_38928() -> var_cultBought
            {
                let var_cultBought_1 := 0
                var_cultBought := 0
                let _1 := loadimmutable("7794")
                let _2 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                if iszero(extcodesize(_2))
                {
                    revert(0, 0)
                }
                let _3 := mload(64)
                mstore(_3, 0xd0e30db000000000000000000000000000000000000000000000000000000000)
                let _4 := call(gas(), _2, 0)
                if iszero(_4)
                {
                    let pos := mload(64)
                    returndatacopy(pos, 0, returndatasize())
                    revert(pos, returndatasize())
                }
                if _4
                {
                    finalize_allocation(_3, 0)
                    var_cultBought_1 := 0
                }
                let _5 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                let expr_mpos := mload(64)
                let _6 := add(expr_mpos, 0x20)
                mstore(_6, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let tail := var_cultBought_1
                tail := add( 100)
                mstore( _5)
                mstore(add( 0x11c37937e08000)
                mstore(expr_mpos, 68)
                finalize_allocation(expr_mpos, 100)
                let expr_component := call(gas(), _1, var_cultBought_1, var_cultBought_1)
                pop(extract_returndata())
                if iszero(expr_component)
                {
                    revert(var_cultBought_1, var_cultBought_1)
                }
                let expr_mpos_1 := mload(64)
                mstore( not(0xffffffffffffffffffffffff)))
                mstore(add( 52), 0x27100000000000000000000000000000000000000000000000000000000000)
                mstore(add( 55), 0xc5dc95539589fbd24be07c6c14eca4000000000000000000000000)
                mstore(expr_mpos_1, 43)
                finalize_allocation(expr_mpos_1, 75)
                let memPtr := mload(64)
                finalize_allocation_38963(memPtr)
                mstore(memPtr, expr_mpos_1)
                let _7 := add(memPtr, 0x20)
                mstore(_7, address())
                let _8 := add(memPtr, 64)
                mstore(_8, timestamp())
                let _9 := add(memPtr, 96)
                mstore(_9, 0x11c37937e08000)
                let _10 := add(memPtr, 128)
                mstore(_10, var_cultBought_1)
                let _11 := mload(64)
                mstore(_11, 0xc04b8d5900000000000000000000000000000000000000000000000000000000)
                mstore( 0x20)
                let memberValue0 := mload(memPtr)
                mstore(add( 160)
                let tail_1 := abi_encode_string(memberValue0, add( 196))
                mstore(add( and(mload(_7), 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add( mload(_8))
                mstore(add( 132), mload(_9))
                mstore(add( 164), mload(_10))
                let trySuccessCondition := call(gas(), _5, 0x20)
                let expr := var_cultBought_1
                if trySuccessCondition
                {
                    let _12 := 0x20
                    if gt( returndatasize()) { _12 := returndatasize() }
                    finalize_allocation(_11, _12)
                    let value0 := 0
                    if slt(sub( 32)
                    {
                        revert( 0, 0)
                    }
                    value0 := mload( _11)
                    expr := value0
                }
                switch iszero(trySuccessCondition)
                case 0 {
                    var_cultBought := expr
                    leave
                }
                default {
                    if eq(147028384, return_data_selector())
                    {
                        let _13 := try_decode_error_message()
                        if _13
                        {
                            if iszero(extcodesize(_2))
                            {
                                revert(var_cultBought_1, var_cultBought_1)
                            }
                            let _14 := mload(64)
                            mstore(_14, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                            mstore( 0x11c37937e08000)
                            let _15 := call(gas(), _2, var_cultBought_1)
                            if iszero(_15)
                            {
                                let pos_1 := mload(64)
                                returndatacopy(pos_1, var_cultBought_1, returndatasize())
                                revert(pos_1, returndatasize())
                            }
                            if _15
                            {
                                finalize_allocation(_14, var_cultBought_1)
                                if var_cultBought_1
                                {
                                    revert(var_cultBought_1, var_cultBought_1)
                                }
                            }
                            let outPtr := mload(64)
                            mstore(add(outPtr, "Swap failed: ")
                            let length := mload(_13)
                            mcopy(add(outPtr, 45), add(_13, length)
                            let _16 := add(outPtr, length)
                            mstore(add(_16, 45), var_cultBought_1)
                            let _17 := add(sub(_16, outPtr), 45)
                            mstore(outPtr, add(_17, not(31)))
                            finalize_allocation(outPtr, _17)
                            let _18 := mload(64)
                            mstore(_18, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore( 0x20)
                            revert(_18, sub( _18))
                        }
                    }
                    let pos_2 := mload(64)
                    returndatacopy(pos_2, var_cultBought_1, returndatasize())
                    revert(pos_2, returndatasize())
                }
            }
            function fun_buyCultWithExactEth(var_ethAmount) -> var_cultBought
            {
                let var_cultBought_1 := 0
                var_cultBought := 0
                let _1 := loadimmutable("7794")
                let _2 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                if iszero(extcodesize(_2))
                {
                    revert(0, 0)
                }
                let _3 := mload(64)
                mstore(_3, 0xd0e30db000000000000000000000000000000000000000000000000000000000)
                let _4 := call(gas(), _2, var_ethAmount, _3, 4, _3, 0)
                if iszero(_4)
                {
                    let pos := mload(64)
                    returndatacopy(pos, 0, returndatasize())
                    revert(pos, returndatasize())
                }
                if _4
                {
                    finalize_allocation(_3, 0)
                    var_cultBought_1 := 0
                }
                let _5 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                let expr_9572_mpos := mload(64)
                let _6 := add(expr_9572_mpos, 0x20)
                mstore(_6, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let _7 := sub(abi_encode_address_uint256(add(expr_9572_mpos, 36), _5, var_ethAmount), expr_9572_mpos)
                mstore(expr_9572_mpos, add(_7, not(31)))
                finalize_allocation(expr_9572_mpos, _7)
                let expr_9573_component := call(gas(), _1, var_cultBought_1, var_cultBought_1)
                pop(extract_returndata())
                if iszero(expr_9573_component)
                {
                    revert(var_cultBought_1, var_cultBought_1)
                }
                let expr_9589_mpos := mload(64)
                mstore( not(0xffffffffffffffffffffffff)))
                mstore(add( 52), 0x27100000000000000000000000000000000000000000000000000000000000)
                mstore(add( 55), 0xc5dc95539589fbd24be07c6c14eca4000000000000000000000000)
                mstore(expr_9589_mpos, 43)
                finalize_allocation(expr_9589_mpos, 75)
                let memPtr := mload(64)
                finalize_allocation_38963(memPtr)
                mstore(memPtr, expr_9589_mpos)
                let _8 := add(memPtr, 0x20)
                mstore(_8, address())
                let _9 := add(memPtr, 64)
                mstore(_9, timestamp())
                let _10 := add(memPtr, 96)
                mstore(_10, var_ethAmount)
                let _11 := add(memPtr, 128)
                mstore(_11, var_cultBought_1)
                let _12 := mload(64)
                mstore(_12, 0xc04b8d5900000000000000000000000000000000000000000000000000000000)
                mstore( 0x20)
                let memberValue0 := mload(memPtr)
                mstore(add( 160)
                let tail := abi_encode_string(memberValue0, add( 196))
                mstore(add( 68), and(mload(_8), 0xffffffffffffffffffffffffffffffffffffffff))
                mstore(add( 100), mload(_9))
                mstore(add( 132), mload(_10))
                mstore(add( 164), mload(_11))
                let trySuccessCondition := call(gas(), _5, 0x20)
                let expr := var_cultBought_1
                if trySuccessCondition
                {
                    let _13 := 0x20
                    if gt( returndatasize()) { _13 := returndatasize() }
                    finalize_allocation(_12, _13)
                    let value0 := 0
                    if slt(sub( 32)
                    {
                        revert( 0, 0)
                    }
                    value0 := mload( _12)
                    expr := value0
                }
                switch iszero(trySuccessCondition)
                case 0 {
                    var_cultBought := expr
                    leave
                }
                default {
                    if eq(147028384, return_data_selector())
                    {
                        let _14 := try_decode_error_message()
                        if _14
                        {
                            if iszero(extcodesize(_2))
                            {
                                revert(var_cultBought_1, var_cultBought_1)
                            }
                            let _15 := mload(64)
                            mstore(_15, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                            mstore( var_ethAmount)
                            let _16 := call(gas(), _2, var_cultBought_1)
                            if iszero(_16)
                            {
                                let pos_1 := mload(64)
                                returndatacopy(pos_1, var_cultBought_1, returndatasize())
                                revert(pos_1, returndatasize())
                            }
                            if _16
                            {
                                finalize_allocation(_15, var_cultBought_1)
                                if var_cultBought_1
                                {
                                    revert(var_cultBought_1, var_cultBought_1)
                                }
                            }
                            let outPtr := mload(64)
                            mstore(add(outPtr, "Swap failed: ")
                            let length := mload(_14)
                            mcopy(add(outPtr, 45), add(_14, length)
                            let _17 := add(outPtr, length)
                            mstore(add(_17, 45), var_cultBought_1)
                            let _18 := add(sub(_17, outPtr), 45)
                            mstore(outPtr, add(_18, not(31)))
                            finalize_allocation(outPtr, _18)
                            let _19 := mload(64)
                            mstore(_19, 0x08c379a000000000000000000000000000000000000000000000000000000000)
                            mstore( 0x20)
                            revert(_19, sub( _19))
                        }
                    }
                    let pos_2 := mload(64)
                    returndatacopy(pos_2, var_cultBought_1, returndatasize())
                    revert(pos_2, returndatasize())
                }
            }
            function fun_calculateIntegralFromZero(var_supply) -> var
            {
                let r := div(var_supply, 0x084595161401484a000000)
                let product := mul(r, 0x0de0b6b3a7640000)
                if iszero(or(iszero(r), eq( div(product, r))))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert( 0x24)
                }
                let product_1 := mul( var_supply)
                if iszero(eq(var_supply, div(product_1, 0x58d15e17628000)))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert( 0x24)
                }
                let _1 := fun_mulWad( product)
                if gt( _1))
                {
                    if _1
                    {
                        mstore( 0xbac65e5b)
                        revert(0x1c, 0x04)
                    }
                }
                pop(fun_mulWad( product))
                let var_z := 0
                var_z := 0
                let _2 := fun_mulWad(product, product)
                if gt( _2))
                {
                    if _2
                    {
                        mstore( 0xbac65e5b)
                        revert(0x1c, 0x04)
                    }
                }
                let _3 := checked_add_uint256( 0x0de0b6b3a7640000))
                let sum := 0
                sum := add( 0)
                if gt( sum)
                {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x11)
                    revert(0, 0x24)
                }
                var := 0x0de0b6b3a7640000))
            }
            function fun_increaseCultLiquidity(var_cultAmount, var_ethAmount) -> var
            {
                let var_1 := 0
                var := 0
                if 0x06))
                {
                    var := 0
                    leave
                }
                let _1 := loadimmutable("7794")
                let _2 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                if iszero(extcodesize(_2))
                {
                    revert(0, 0)
                }
                let _3 := mload(64)
                mstore(_3, 0xd0e30db000000000000000000000000000000000000000000000000000000000)
                let _4 := call(gas(), _2, var_ethAmount, _3, 4, _3, 0)
                if iszero(_4)
                {
                    let pos := mload(64)
                    returndatacopy(pos, 0, returndatasize())
                    revert(pos, returndatasize())
                }
                if _4
                {
                    finalize_allocation(_3, 0)
                    var_1 := 0
                }
                let _5 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                let expr_9891_mpos := mload(64)
                let _6 := add(expr_9891_mpos, 0x20)
                mstore(_6, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let _7 := sub(abi_encode_address_uint256(add(expr_9891_mpos, 36), _5, var_cultAmount), expr_9891_mpos)
                mstore(expr_9891_mpos, add(_7, not(31)))
                finalize_allocation(expr_9891_mpos, _7)
                let expr_9892_component := call(gas(), var_1, var_1)
                pop(extract_returndata())
                if iszero(expr_9892_component) { revert(var_1, var_1) }
                let expr_9911_mpos := mload(64)
                let _8 := add(expr_9911_mpos, 0x20)
                mstore(_8, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
                let _9 := sub(abi_encode_address_uint256(add(expr_9911_mpos, _5, var_ethAmount), expr_9911_mpos)
                mstore(expr_9911_mpos, add(_9, not(31)))
                finalize_allocation(expr_9911_mpos, _9)
                let expr_9912_component := call(gas(), _1, var_1, var_1)
                pop(extract_returndata())
                if iszero(expr_9912_component) { revert(var_1, var_1) }
                let _10 := sload( 0x06)
                let expr := lt( _2)
                let expr_1 := var_1
                switch expr
                case 0 { expr_1 := var_ethAmount }
                default { expr_1 := var_cultAmount }
                let expr_2 := var_1
                switch expr
                case 0 { expr_2 := var_cultAmount }
                default { expr_2 := var_ethAmount }
                let memPtr := mload(64)
                let newFreePtr := add(memPtr, 192)
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr))
                {
                    mstore( 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore( 0x41)
                    revert( 36)
                }
                mstore(64, newFreePtr)
                mstore(memPtr, _10)
                let _11 := add(memPtr, 0x20)
                mstore(_11, expr_1)
                let _12 := add(memPtr, 64)
                mstore(_12, expr_2)
                let _13 := add(memPtr, 96)
                mstore(_13, var_1)
                let _14 := add(memPtr, 128)
                mstore(_14, var_1)
                let _15 := add(memPtr, 160)
                mstore(_15, timestamp())
                let _16 := mload(64)
                mstore(_16, 0x219f5d1700000000000000000000000000000000000000000000000000000000)
                mstore( mload(memPtr))
                mstore(add( mload(_11))
                mstore(add( 68), mload(_12))
                mstore(add( 100), mload(_13))
                mstore(add( 132), mload(_14))
                mstore(add( 164), mload(_15))
                let trySuccessCondition := call(gas(), _5, 96)
                if trySuccessCondition
                {
                    let _17 := 96
                    if gt( returndatasize()) { _17 := returndatasize() }
                    finalize_allocation(_16, _17)
                    if slt(sub( 96)
                    { revert(var_1, var_1) }
                    pop(abi_decode_uint128_fromMemory(_16))
                }
                switch iszero(trySuccessCondition)
                case 0 {
                    let expr_9960_mpos := mload(64)
                    let _18 := add(expr_9960_mpos, 0x20)
                    mstore(_18, 0x70a0823100000000000000000000000000000000000000000000000000000000)
                    mstore( address())
                    mstore(expr_9960_mpos, 36)
                    finalize_allocation(expr_9960_mpos, 68)
                    pop(staticcall(gas(), _1, _18, mload(expr_9960_mpos), var_1, var_1))
                    let expr_component_mpos := extract_returndata()
                    let _19 := expr_component_mpos)
                    let headStart := add(expr_component_mpos, 0x20)
                    let value0 := 0
                    if slt(sub( headStart), 32)
                    {
                        revert( 0, 0)
                    }
                    value0 := mload(headStart)
                    if value0))
                    {
                        if iszero(extcodesize(_2))
                        {
                            revert(var_1, var_1)
                        }
                        let _20 := mload(64)
                        mstore(_20, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                        mstore( value0)
                        let _21 := call(gas(), _2, var_1)
                        if iszero(_21)
                        {
                            let pos_1 := mload(64)
                            returndatacopy(pos_1, var_1, returndatasize())
                            revert(pos_1, returndatasize())
                        }
                        if _21
                        {
                            finalize_allocation(_20, var_1)
                            if var_1 { revert(var_1, var_1) }
                        }
                    }
                    var := 0x01
                    leave
                }
                default {
                    if eq(147028384, return_data_selector())
                    {
                        if try_decode_error_message()
                        {
                            if iszero(extcodesize(_2))
                            {
                                revert(var_1, var_1)
                            }
                            let _22 := mload(64)
                            mstore(_22, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                            mstore( var_ethAmount)
                            let _23 := call(gas(), _2, var_1)
                            if iszero(_23)
                            {
                                let pos_2 := mload(64)
                                returndatacopy(pos_2, var_1, returndatasize())
                                revert(pos_2, returndatasize())
                            }
                            if _23
                            {
                                finalize_allocation(_22, var_1)
                                if var_1 { revert(var_1, var_1) }
                            }
                            var := var_1
                            leave
                        }
                    }
                    let pos_3 := mload(64)
                    returndatacopy(pos_3, var_1, returndatasize())
                    revert(pos_3, returndatasize())
                }
            }
        }
        data ".metadata" hex"a2646970667358221220d25779b77a2730d0593b83b85f81914eb93c34c85f31c5e482682d416647609f64736f6c634300081a0033"
    }
    object "DN404Mirror_5061" {
        code {
            {
                let _1 := memoryguard(0x80)
                if callvalue() { revert(0, 0) }
                let programSize := datasize("DN404Mirror_5061")
                let argSize := sub(codesize(), programSize)
                let newFreePtr := add(_1, and(add(argSize, 31), not(31)))
                if or(gt(newFreePtr, sub(shl(64, 1), 1)), lt(newFreePtr, _1))
                {
                    mstore( shl(224, 0x4e487b71))
                    mstore(4, 0x41)
                    revert( 0x24)
                }
                mstore(64, newFreePtr)
                codecopy(_1, programSize, argSize)
                if slt(sub(add(_1, argSize), _1), 32)
                {
                    revert( 0, 0)
                }
                let value := mload(_1)
                let _2 := and(value, sub(shl(160, 1), 1))
                if iszero(eq(value, _2))
                {
                    revert( 0, 0)
                }
                sstore( not(sub(shl(160, 1), 1))), _2))
                let _3 := mload(64)
                let _4 := datasize("DN404Mirror_5061_deployed")
                codecopy(_3, dataoffset("DN404Mirror_5061_deployed"), _4)
                return(_3, _4)
            }
        }
        object "DN404Mirror_5061_deployed" {
            code {
                {
                    let _1 := memoryguard(0x80)
                    mstore(64, _1)
                    if iszero(lt(calldatasize(), 4))
                    {
                        switch shr(224, calldataload(0))
                        case 0x01ffc9a7 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let value := calldataload(4)
                            if iszero(eq(value, and(value, 0xffffffff00000000000000000000000000000000000000000000000000000000))) { revert(0, 0) }
                            let usr$s := shr( value)
                            mstore(_1, iszero(iszero( or(or(eq(usr$s, 0x01ffc9a7), eq(usr$s, 0x80ac58cd)), eq(usr$s, 0x5b5e139f)))))
                            return(_1, 32)
                        }
                        case 0x06fdde03 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let var_result_mpos := 0
                            let expr := fun_baseERC20()
                            var_result_mpos := mload( 64)
                            mstore( 0x06fdde03)
                            mstore(0x20, 0)
                            if iszero(staticcall(gas(), expr, 0x1c, 0x24, 0, 0))
                            {
                                returndatacopy(var_result_mpos, returndatasize())
                                revert(var_result_mpos, returndatasize())
                            }
                            returndatacopy( 0x20)
                            returndatacopy(var_result_mpos, mload( 0x20)
                            returndatacopy(add(var_result_mpos, 0x20), add(mload( 0x20), mload(var_result_mpos))
                            let _2 := add(var_result_mpos, mload(var_result_mpos))
                            mstore(add(_2, 0x20), 0)
                            mstore( 64))
                            let memPos := mload(64)
                            return(memPos, sub(abi_encode_string(memPos, var_result_mpos), memPos))
                        }
                        case 0x081812fc {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let var_result := 0
                            let expr_1 := fun_baseERC20()
                            let usr$m := mload( 64)
                            mstore( 0x27ef5495)
                            mstore( 32, calldataload(4))
                            mstore( 64, 0)
                            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr_1, 0x1c, 0x44, 0, 32)))
                            {
                                returndatacopy(usr$m, returndatasize())
                                revert(usr$m, returndatasize())
                            }
                            mstore( usr$m)
                            var_result := mload( 0)
                            let memPos_1 := mload(64)
                            mstore(memPos_1, and(var_result, 0xffffffffffffffffffffffffffffffffffffffff))
                            return(memPos_1, 32)
                        }
                        case 0x095ea7b3 {
                            if slt(add(calldatasize(), not(3)), 64) { revert(0, 0) }
                            let value0 := abi_decode_address()
                            let value_1 := calldataload(36)
                            let expr_2 := fun_baseERC20()
                            let var_spender := and(value0, 0xffffffffffffffffffffffffffffffffffffffff)
                            let usr$m_1 := mload( 64)
                            mstore( 0xd10b6e0c)
                            mstore( var_spender)
                            mstore( value_1)
                            mstore(96, caller())
                            if iszero(and(gt(returndatasize(), 0x1f), call(gas(), expr_2, callvalue(), 0x1c, 0x64, 0, 32)))
                            {
                                returndatacopy(usr$m_1, returndatasize())
                                revert(usr$m_1, returndatasize())
                            }
                            log4( 63486140976153616755203102783360879283472101686154884697241723088393386309925, shr(96, mload(0x0c)), var_spender, value_1)
                            return(0, 0)
                        }
                        case 0x18160ddd {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let var_result_1 := 0
                            let expr_3 := fun_baseERC20()
                            let usr$m_2 := mload( 64)
                            mstore( 0xe2c79281)
                            mstore(0x20, 0)
                            mstore( 64, 0)
                            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr_3, 0x1c, 0x44, 0x20)))
                            {
                                returndatacopy(usr$m_2, returndatasize())
                                revert(usr$m_2, returndatasize())
                            }
                            mstore( usr$m_2)
                            var_result_1 := mload( 0)
                            let memPos_2 := mload(64)
                            mstore(memPos_2, var_result_1)
                            return(memPos_2, 0x20)
                        }
                        case 0x23b872dd {
                            let param, param_1, param_2 := abi_decode_addresst_addresst_uint256(calldatasize())
                            fun_transferFrom(param, param_1, param_2)
                            return(0, 0)
                        }
                        case 0x24359879 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let var_result_2 := 0
                            let expr_4 := fun_baseERC20()
                            let usr$m_3 := mload( 64)
                            mstore( 0xc016aa52)
                            mstore( 32, calldataload(4))
                            mstore( 64, 0)
                            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr_4, 0x1c, 0x44, 0, 32)))
                            {
                                returndatacopy(usr$m_3, returndatasize())
                                revert(usr$m_3, returndatasize())
                            }
                            mstore( usr$m_3)
                            var_result_2 := mload( 0)
                            let memPos_3 := mload(64)
                            mstore(memPos_3, and(var_result_2, 0xffffffffffffffffffffffffffffffffffffffff))
                            return(memPos_3, 32)
                        }
                        case 0x42842e0e {
                            let param_3, param_4, param_5 := abi_decode_addresst_addresst_uint256(calldatasize())
                            fun_transferFrom(param_3, param_4, param_5)
                            if extcodesize(param_4)
                            {
                                let usr$m_4 := mload( 64)
                                mstore(usr$m_4, 0x150b7a02)
                                mstore(add(usr$m_4, 0x20), caller())
                                mstore(add(usr$m_4, and(param_3, 0xffffffffffffffffffffffffffffffffffffffff))
                                mstore(add(usr$m_4, 96), param_5)
                                mstore(add(usr$m_4, 0x80), 0x80)
                                mstore(add(usr$m_4, 0xa0), 0)
                                calldatacopy( 0, calldatasize(), 0)
                                if iszero(call(gas(), param_4, add(usr$m_4, 0x1c), 0xa4, usr$m_4, 0x20))
                                {
                                    if returndatasize()
                                    {
                                        returndatacopy(usr$m_4, returndatasize())
                                        revert(usr$m_4, returndatasize())
                                    }
                                }
                                if iszero(eq(mload(usr$m_4), 0x150b7a0200000000000000000000000000000000000000000000000000000000))
                                {
                                    mstore( 0xd1a57ed6)
                                    revert(0x1c, 4)
                                }
                            }
                            return(0, 0)
                        }
                        case 0x6352211e {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let cleaned := and( calldataload(4)), 0xffffffffffffffffffffffffffffffffffffffff)
                            let memPos_4 := mload(64)
                            mstore(memPos_4, cleaned)
                            return(memPos_4, 32)
                        }
                        case 0x6cef16e6 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let expr_5 := fun_baseERC20()
                            let _3 := sload( 0x3602298b8c10b01232)
                            let cleaned_1 := and(_3, 0xffffffffffffffffffffffffffffffffffffffff)
                            mstore( 0x8da5cb5b)
                            let usr$success := staticcall(gas(), expr_5, 0x1c, 0x20)
                            let var_newOwner := mul(shr(96, mload(0x0c)), and(gt(returndatasize(), 0x1f), usr$success))
                            if iszero(usr$success)
                            {
                                if and(shl(96, not(0xffffffffffffffffffffffff))
                                {
                                    revert( 0, 0)
                                }
                            }
                            let _4 := and( 0xffffffffffffffffffffffffffffffffffffffff)
                            if cleaned_1, _4))
                            {
                                sstore( 0xffffffffffffffffffffffff0000000000000000000000000000000000000000), _4))
                                log3( 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, cleaned_1, _4)
                            }
                            let memPos_5 := mload(64)
                            mstore(memPos_5, 0x01)
                            return(memPos_5, 0x20)
                        }
                        case 0x70a08231 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let _5 := and(abi_decode_address(), 0xffffffffffffffffffffffffffffffffffffffff)
                            let var_result_3 := 0
                            let expr_6 := fun_baseERC20()
                            let usr$m_5 := mload( 64)
                            mstore( 0xf5b100ea)
                            mstore( _5)
                            mstore( 64, 0)
                            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr_6, 0x1c, 0x44, 0, 32)))
                            {
                                returndatacopy(usr$m_5, returndatasize())
                                revert(usr$m_5, returndatasize())
                            }
                            mstore( usr$m_5)
                            var_result_3 := mload( 0)
                            let memPos_6 := mload(64)
                            mstore(memPos_6, var_result_3)
                            return(memPos_6, 32)
                        }
                        case 0x8da5cb5b {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let cleaned_2 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                            let memPos_7 := mload(64)
                            mstore(memPos_7, cleaned_2)
                            return(memPos_7, 32)
                        }
                        case 0x95d89b41 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let var_result_mpos_1 := 0
                            let expr_7 := fun_baseERC20()
                            var_result_mpos_1 := mload( 64)
                            mstore( 0x95d89b41)
                            mstore(0x20, 0)
                            if iszero(staticcall(gas(), expr_7, 0x1c, 0x24, 0, 0))
                            {
                                returndatacopy(var_result_mpos_1, returndatasize())
                                revert(var_result_mpos_1, returndatasize())
                            }
                            returndatacopy( 0x20)
                            returndatacopy(var_result_mpos_1, mload( 0x20)
                            returndatacopy(add(var_result_mpos_1, 0x20), add(mload( 0x20), mload(var_result_mpos_1))
                            let _6 := add(var_result_mpos_1, mload(var_result_mpos_1))
                            mstore(add(_6, 0x20), 0)
                            mstore( 64))
                            let memPos_8 := mload(64)
                            return(memPos_8, sub(abi_encode_string(memPos_8, var_result_mpos_1), memPos_8))
                        }
                        case 0x97e5311c {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 0) { revert(0, 0) }
                            let ret := fun_baseERC20()
                            let memPos_9 := mload(64)
                            mstore(memPos_9, and(ret, 0xffffffffffffffffffffffffffffffffffffffff))
                            return(memPos_9, 32)
                        }
                        case 0xa22cb465 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 64) { revert(0, 0) }
                            let value0_1 := abi_decode_address()
                            let value_2 := calldataload(36)
                            let _7 := iszero(iszero(value_2))
                            if iszero(eq(value_2, _7)) { revert(0, 0) }
                            let expr_8 := fun_baseERC20()
                            let var_operator := and(value0_1, 0xffffffffffffffffffffffffffffffffffffffff)
                            let usr$m_6 := mload( 64)
                            mstore( 0xf6916ddd)
                            mstore( var_operator)
                            mstore( _7)
                            mstore(96, caller())
                            if iszero(and(eq(mload( 0, 32)))
                            {
                                returndatacopy(usr$m_6, returndatasize())
                                revert(usr$m_6, returndatasize())
                            }
                            log3( 10488878412788366941768124514102328501031624832915735463117339209566108871729, caller(), var_operator)
                            return(0, 0)
                        }
                        case 0xb88d4fde {
                            if slt(add(calldatasize(), not(3)), 128) { revert(0, 0) }
                            let value0_2 := abi_decode_address()
                            let value1 := abi_decode_address_4414()
                            let value_3 := calldataload(68)
                            let offset := calldataload(100)
                            if gt(offset, 0xffffffffffffffff) { revert(0, 0) }
                            if iszero(slt(add(offset, 35), calldatasize())) { revert(0, 0) }
                            let length := calldataload(add(4, offset))
                            if gt(length, 0xffffffffffffffff) { revert(0, 0) }
                            if gt(add(add(offset, length), 36), calldatasize()) { revert(0, 0) }
                            fun_transferFrom(value0_2, value1, value_3)
                            if extcodesize(value1)
                            {
                                let usr$m_7 := mload( 64)
                                mstore(usr$m_7, 0x150b7a02)
                                mstore(add(usr$m_7, caller())
                                mstore(add(usr$m_7, and(value0_2, 0xffffffffffffffffffffffffffffffffffffffff))
                                mstore(add(usr$m_7, 96), value_3)
                                mstore(add(usr$m_7, 128), 128)
                                mstore(add(usr$m_7, 0xa0), length)
                                calldatacopy(add(usr$m_7, 0xc0), length)
                                if iszero(call(gas(), value1, 32))
                                {
                                    if returndatasize()
                                    {
                                        returndatacopy(usr$m_7, returndatasize())
                                        revert(usr$m_7, returndatasize())
                                    }
                                }
                                if iszero(eq(mload(usr$m_7), 0x150b7a0200000000000000000000000000000000000000000000000000000000))
                                {
                                    mstore( 0xd1a57ed6)
                                    revert(0x1c, 4)
                                }
                            }
                            return(0, 0)
                        }
                        case 0xc87b56dd {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 32) { revert(0, 0) }
                            let value_4 := calldataload(4)
                            pop(fun_readWord(value_4))
                            let var_result_mpos_2 := 0
                            let expr_9 := fun_baseERC20()
                            var_result_mpos_2 := mload( 64)
                            mstore( 0xcb30b460)
                            mstore( value_4)
                            if iszero(staticcall(gas(), expr_9, 0x1c, 0x24, 0, 0))
                            {
                                returndatacopy(var_result_mpos_2, returndatasize())
                                revert(var_result_mpos_2, returndatasize())
                            }
                            returndatacopy( 0, 0, 32)
                            returndatacopy(var_result_mpos_2, mload( 0), 32)
                            returndatacopy(add(var_result_mpos_2, mload(var_result_mpos_2))
                            let _8 := add(var_result_mpos_2, mload(var_result_mpos_2))
                            mstore(add(_8, 32), 0)
                            mstore( 64))
                            let memPos_10 := mload(64)
                            return(memPos_10, sub(abi_encode_string(memPos_10, var_result_mpos_2), memPos_10))
                        }
                        case 0xe985e9c5 {
                            if callvalue() { revert(0, 0) }
                            if slt(add(calldatasize(), not(3)), 64) { revert(0, 0) }
                            let value0_3 := abi_decode_address()
                            let value1_1 := abi_decode_address_4414()
                            let var_result_4 := 0
                            let expr_10 := fun_baseERC20()
                            let usr$m_8 := mload( 64)
                            mstore( 0x62fb246d)
                            mstore( 0xffffffffffffffffffffffffffffffffffffffff))
                            mstore( 0xffffffffffffffffffffffffffffffffffffffff))
                            if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr_10, 0x1c, 0x44, 0, 32)))
                            {
                                returndatacopy(usr$m_8, returndatasize())
                                revert(usr$m_8, returndatasize())
                            }
                            mstore( usr$m_8)
                            var_result_4 := mload( 0)
                            let memPos_11 := mload(64)
                            mstore(memPos_11, iszero(iszero(var_result_4)))
                            return(memPos_11, 32)
                        }
                    }
                    if iszero(calldatasize())
                    {
                        if callvalue()))
                        {
                            revert( 0x00, 0x00)
                        }
                        stop()
                    }
                    let result := shr( 0x00))
                    if 0x263c69d6)
                    {
                        if 0xffffffffffffffffffffffffffffffffffffffff)))
                        {
                            mstore( 0x363cb312)
                            revert(0x1c, 4)
                        }
                        let _9 := calldataload( 4)
                        let usr$o := add(0x24, _9)
                        let usr$end := add(add(_9, shl(5, calldataload(add(_9, 0x24)
                        for { } iszero(eq(usr$o, usr$end)) { usr$o := add(0x20, usr$o) }
                        {
                            let usr$d := calldataload(usr$o)
                            let usr$a := shr(96, usr$d)
                            let usr$b := and(1, usr$d)
                            log4( 100389287136786176327247604509743168900146139575972864366142685224231313322991, mul(usr$a, usr$b), mul(usr$a, iszero(usr$b)), and(shr(8, usr$d), 0xffffffffffffffffffffff))
                        }
                        mstore( 1)
                        return( 0x20)
                    }
                    if 0x144027d3)
                    {
                        if 0xffffffffffffffffffffffffffffffffffffffff)))
                        {
                            mstore( 0x363cb312)
                            revert(0x1c, 4)
                        }
                        let usr$from := calldataload( 4)
                        let usr$to := calldataload(0x24)
                        let _10 := calldataload(0x44)
                        let usr$o_1 := add(0x24, _10)
                        let usr$end_1 := add(add(_10, shl(5, calldataload(add(_10, 0x24)
                        for { }
                        iszero(eq(usr$o_1, usr$end_1))
                        { usr$o_1 := add(0x20, usr$o_1) }
                        {
                            log4( 100389287136786176327247604509743168900146139575972864366142685224231313322991, usr$from, usr$to, calldataload(usr$o_1))
                        }
                        mstore( 0x01)
                        return( 0x20)
                    }
                    if 0x0f4599e5)
                    {
                        let cleaned_3 := and(sload( 0xffffffffffffffffffffffffffffffffffffffff)
                        if cleaned_3))
                        {
                            if cleaned_3))
                            {
                                mstore( 0xc59ec47a)
                                revert(0x1c, 4)
                            }
                        }
                        let _11 := sload( 0x3602298b8c10b01230)
                        if and(_11, 0xffffffffffffffffffffffffffffffffffffffff)))
                        {
                            mstore( 0xbf656a46)
                            revert(0x1c, 4)
                        }
                        sstore( caller()))
                        mstore( 1)
                        return( 0x20)
                    }
                    mstore( 0x3c10b94e)
                    revert(0x1c, 4)
                }
                function abi_encode_string(headStart, value0) -> tail
                {
                    mstore(headStart, 32)
                    let length := mload(value0)
                    mstore(add(headStart, 32), length)
                    mcopy(add(headStart, 64), add(value0, 32), length)
                    mstore(add(add(headStart, length), 64), 0)
                    tail := add(add(headStart, and(add(length, 31), not(31))), 64)
                }
                function abi_decode_address() -> value
                {
                    value := calldataload(4)
                    if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
                }
                function abi_decode_address_4414() -> value
                {
                    value := calldataload(36)
                    if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
                }
                function abi_decode_addresst_addresst_uint256(dataEnd) -> value0, value1, value2
                {
                    if slt(add(dataEnd, not(3)), 96) { revert(0, 0) }
                    let value := 0
                    value := calldataload(4)
                    if iszero(eq(value, and(value, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
                    value0 := value
                    let value_1 := 0
                    value_1 := calldataload(36)
                    if iszero(eq(value_1, and(value_1, 0xffffffffffffffffffffffffffffffffffffffff))) { revert(0, 0) }
                    value1 := value_1
                    value2 := calldataload(68)
                }
                function fun_transferFrom(var_from, var_to, var_id)
                {
                    let expr := fun_baseERC20()
                    let var_from_1 := and(var_from, 0xffffffffffffffffffffffffffffffffffffffff)
                    let var_to_1 := and(var_to, 0xffffffffffffffffffffffffffffffffffffffff)
                    let usr$m := mload(0x40)
                    mstore(usr$m, 0xe5eb36c8)
                    mstore(add(usr$m, 0x20), var_from_1)
                    mstore(add(usr$m, 0x40), var_to_1)
                    mstore(add(usr$m, 96), var_id)
                    mstore(add(usr$m, 0x80), caller())
                    if iszero(and(eq(mload(usr$m), 1), call(gas(), expr, callvalue(), add(usr$m, 0x1c), 0x84, usr$m, 0x20)))
                    {
                        returndatacopy(usr$m, 0x00, returndatasize())
                        revert(usr$m, returndatasize())
                    }
                    log4(0x00, 0x00, 100389287136786176327247604509743168900146139575972864366142685224231313322991, var_from_1, var_to_1, var_id)
                }
                function fun_baseERC20() -> var_base
                {
                    var_base := 0xffffffffffffffffffffffffffffffffffffffff)
                    if var_base)
                    {
                        mstore( 0x5b2a47ae)
                        revert(0x1c, 0x04)
                    }
                }
                function fun_readWord(var_arg0) -> var_result
                {
                    let expr := fun_baseERC20()
                    let usr$m := mload(0x40)
                    mstore( 0x2d8a746e)
                    mstore(0x20, var_arg0)
                    mstore(0x40, 0)
                    if iszero(and(gt(returndatasize(), 0x1f), staticcall(gas(), expr, 0x1c, 0x44, 0x20)))
                    {
                        returndatacopy(usr$m, returndatasize())
                        revert(usr$m, returndatasize())
                    }
                    mstore(0x40, usr$m)
                    var_result := mload( 0)
                }
            }
            data ".metadata" hex"a2646970667358221220945ad5e8eb60e7f1d5d74ac9218c28d888d3adb9d996f5d0a57eeaa2ef637bb764736f6c634300081a0033"
        }
    }
}

