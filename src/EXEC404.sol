/*#+-++#+----+##+++++......-.....++++##+++###++++---++..............................................................-...--------.---..
####+++++++++#####+++--+++###+-+-#++++#####+++#+++###+--+++###############+-++++-++#####+++-+++#######+++######++++++++##########++++-
####+++--------####+--+--------+.-----#####------+-.----+++--------------.+-++--++#-----.+++-++------##++.----.++++-+##.--------###-+-
###++------------##++--.----.++#.-----++++++----.+-------+#--------------.#-+-----#------++--+#.------+##.-----#++-+#.------------#++.
###+------#+#-----##+#-.----.+--.-----+#+++-----.#+++++++++---+------+----+-------#------++++++.-------.#-----.#+++#.------#+------++.
##+#-----#+++#--+.##++#.----.#--.-----++++++----.#-----+--++++#+-----++++---------+------+--+-+.---------+-----#++++------#+##.....++.
##+.-----++++#########++-----++#+-----++#++-----.#-------------+-----++-----------+-----------+.--------------.#+-++------#++#######+.
##+#-----++++#-----###++-----+++#-----++++++----.#+++++--------------+------------+-----------+.----#----------#+-++------###+-----++.
###+-------#------+##++#------+------#++++++-----------.--------------------------------.------.----+#---------#+-+#-------..-----.+-.
+##++#-----------+++#+#+#-----------##++++++--------------------------------------------.------------+++------.+-+-+#+-----------+#++.
####+++++-----#+++++++++#+##-----+#++#++++++--------------------+++++------+++-----+++++----------------#.-----+----++##.-----.+##++-.
-#+--++++++#++++++++++++++#++++++++++#++++++#-+-++-----------.--------..-.-----..-----------------+------+++++++-------++#####+++----.
-#+#####++++####+##+##+#+++++++++++++#++++++#---------------------------------------------------------------------+---------------++-.
-#+###+##########+##+##+####+++++++++#++++++#-------------------------.....------------------------------------------------+++++-----.
##+++##+##+##############++#####+++++#++++++#------------------------...#+...-----------------.--------------------------------------.
-+###+#++####++++++++++++++++++####+++++++++#.----.---------------....#####...------------------------------------------+------------.
###+##++#+++++++++++++#####+++++++###+++++++#.--------...............#######..-------------------------------------------------------.
+####-#######+++++++++++++##++#####++##+++++#.--------.#####...##############..------------------------------------------------------.
##++######+#++++++++++#+++++#+++###+++++#+++#.--------..######################..----------.....--.....-------------------------------.
+#+#######+##+++###++++++++++--+++##+++++#++#.--------...#####################-.---------........-...........-......-----------------.
+####++########++--+#############--+++++++###..--------...#####################.--------..#####-.#####...###.-##.##-.--#+-.-..-------.
#############++-###+###############+-+++++++#-..--------..#####################..-------..#####.######...##....###-#....+####+-------.
#####++++###+######-##################++++++##-..-------..#####################..-------..-.#.##.#.-##.-#.###+#+.##..#########.------.
############+++-##++###################-++++++#+..------..##########--#########..--------.........................#########...-------.
#####+###+++++++--+----##################+++++###.-------..####################..-------------------------....##########...----------.
#####+##+-++++-###+####---################-++++##--------..#####################...-------------------.....#########....-------------.
#######+####+-####-+###++++-###############-##++##--------..####################+#...--------------.....#########....----------------.
###+##---#########-+####----+###############-#+#+#---------...################+++##-....-------.....+########+....-------------------.
++++++#-####################-++##############++++#---------....-############+..+-#####...........#########-....----------------------.
####+########################-+##############++#++#-........#########-+##+...--+##########+...#########........--.--.----------------.
####++-######++-##############++##############+##++###+++-###########-#++..---+#####################.........-------#---+++++########+
###++++#+----++##############-.#+#############-+#++##+#-++###############+-.-++###################+.+##############++++++++++++++++++-
###++#++#######+++##############+#############+++++##+#################---++++#########+--############################++++++++++++++++
###++.#+---####----..#######+.#---+##..#+..###--+++-----################++-.+#######---++##########+++++++++++++++++++++++++++++++++++
##++++---+++-##-#----#######.##.#-###..##.-.##.-+#--+++.################+.++#####--++++#############++++++++++++++++++++++++++++++++++
##+++++#---.+#+#+-#-.#######-#.---.##..##.-..#.-+--#++##################++###+--++++#################+++++++++++++++++++++++++++++++++
##+#++#-+#-+##++.-#-#########-----###..##.##.---+---###################++#+--++#######################++++++++++++++++++++++++++++++++
+#+#+--.-----++#+#--###..###+.#-#--##..##.-##---++-.....-#########+++++++++###########################++++++++++++++++++++++++++++++++
-#++++#++####++++#+#############+++#######+###++#################-++++++-+############################++++++++++++++++++++++++++++++++
##+++#++###+++++++++++#+++-+####+++#######+#####################+++++++################################+++++++++++++++++++++++++++++++
##+++#+++++++++++++++++++#++####+++#######+############+-######--+++##+#################################++++++++++++++++++++++++++++++
###++#+++++##++++.+++++++##-+###+-#######++############-##############-##################################+++++++++++++++++++++++++++++
###++#+#++++++++#+#+##++#+-###+-#########+#############-#################################################+++++++++++++++++++++++++++++
###+++-+++++++++++++#++++++############################-##################################################++++++++++++++++++++++++++++
####+++++++++++++++-++++#+++#-+-############+++#########+++#####+##########################################+++++++++++++++++++++++++++
####++++#.+#+++++#++#+-++####+++#######++###++++--++++++++++-+--############################################++++++++++++++++++++++++++
##+##+#++++#++##.++++####-++++########+#####+++++++++++++++++++##############################################+++++++++++++++++++++++++
##++##+++#++#++++++++++++++++########+#####++##+++++++++++++-+###############################################+++++++++++++++++++++++++
#######+++++++##++++++++++++########+#####++##+-++++++++++###################################################++++++##+++++++++++++++++
########+++++++##++++++++++#######++##++#++++###++++++++++##################################################++++++#-++++++++++++++++++
##########+++++++++++++++#######+++++-+#++++++#+++++++++++#################################################+++++++#.#+++++++++++++++++
####+##-+##++++++#+++++######+++#++++#++++++++++++++++++++#############+###################################++++#+##-###+++++++++++++++
#############+++-##++####++++++++++##++++++#++++++++++++++################################################+++++--------###++++++++++++
################+--++++++++++++++##++++++##+++++++++++++++############+##################################++-############-#+#++++++++++
#####################++++++#####++++++++#++++++++++++++++##############################################++-###-.....-...-##--#+++++++++
##############+#############++++++++++##+++++++++++++++++#############################################++###...#---##----..##+#++++++++
######################+++++++###++++##+++++++++++++++++++############################################+-+#.#.-...--.----....-#-++++++++
#########################+###########+++++++####++++++++#############################################++##.-+-##-.---....###.##+#++++++
############+#####.+#####+#+..##....#++#+##+.#.###++++++######.#######.......#######################+++#..-.-.-##...-##-.....#++#+++++
+#############..........##++..+.#....+++.........#++++#+.##.##.#..####.##.##..######################+-##-##----..###-..---+#.#+-#+++++
+#############+###.+########..#+...##++##.#+.#.###+++++-###.##..######.##.##.######.################++##....----....-------..#-#++++++
+#################.##.+##+....+.-#..#+++..##...#++++++##..#.#.....####........-######################++#+-##--------------..+#+#++++++
+++#####++++###..++.-.++++-#.###..##+++##......+##++++#.-##.#..#-.###########.####+.#################++##-....-----------+#-##++++++++
+##########+#...+#+++...+++#.##..#+..++..##+.###.#+++++.##.##.#....#######....########################+++##..##.--+---#...##++++++++++
+#+++#++++++#+##+++++##+++#+++##++++#++###++#++###++++##################################################++###-...--....-####++++++++++
+####+#+#+#+#+#++++++++++#+++####++#++++++++++++++++++####################################################+++############+++++++++++++
+##+#######+##+++++###++++++++++##+++++++++++++++++++-#######################################################+++++++++++++++++++++++++
+######+++++#+++++++++++++++####+++++++++++++++++++++-#########################################################+++++++##++++++++++++++
+###+######+#++++++++++++++++####++++++++++++++++++++###########################################################+++++++++++#+++++++##+
+#######+##+#++##+++++++++++++--++#+++++++++++++++++-###########################################################+++++++++++#++++++++++
+#+++###++#+###+++++++++++++####++++++++++++++++++###############################################################+++++++++++++++++++++
++##+########++++++++++++###++++#++++++++++++######+####-+++#####################################################+++++++++++++++++++++
-++++++------+++-+---+##+---+++-+++++++++++++####---##-++++-+#####################################################++++++++++++++++++*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { DN404 } from "dn404/src/DN404.sol";
import { DN404Mirror } from "dn404/src/DN404Mirror.sol";
import { FixedPointMathLib } from "solady/utils/FixedPointMathLib.sol";
import { SafeTransferLib } from "solady/utils/SafeTransferLib.sol";
import { LibString } from "solady/utils/LibString.sol";
import { MerkleProofLib } from "solady/utils/MerkleProofLib.sol";
import { IUniswapV3SwapCallback } from "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol";

/// @title EXEC404 - A DN404 token with advanced liquidity and NFT features
/// @notice This contract extends DN404 with the following key features:
/// @dev Implements bonding curve, liquidity provision, and NFT mechanics
///
/// Key Features:
/// - 12-day presale with daily sequential merkle tree whitelisting
/// - Automatic liquidity deployment after presale period
/// - Buy/sell taxes that convert to CULT-ETH liquidity
/// - NFT minting disabled by default (skipNFT = true)
/// - Balance-based NFT minting system
/// - Designated NFT holder can collect liquidity position fees
/// - Portion of deployed liquidity allocated to designated NFT holder
/// - On-chain message system for buys/sells
/// - Gas optimized within bytecode limits
/// - NFT ID tracking per user
///
/// Made by Arthur T. McDonald (twitter: x.com/miladystation)
/// Website: ms2.fun
/// For the Milady Cult Coin community
///

// ┌───────────────────────────────────────────────────────────────┐
// │                                                               │
// │            CULT EXEC DUAL NATURE SMART CONTRACT               │
// │                                                               │
// └───────────────────────────────────────────────────────────────┘

contract EXEC404 is DN404, IUniswapV3SwapCallback {

    // ┌─────────────────────────┐
    // │         Types           │
    // └─────────────────────────┘

    struct BondingMessage {
        address sender;      // 20 bytes
        uint128 packedData; // 16 bytes (contains timestamp:32 | amount:95 | isBuy:1)
        string message;     // variable length
    }

    // ┌─────────────────────────┐
    // │        Externals        │
    // └─────────────────────────┘

    address public constant CULT = 0x0000000000c5dc95539589fbD24BE07c6C14eCa4;
    
    address private constant router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private constant positionManager = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;
    address private constant factory3 = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
    address private constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address private constant OPERATOR_NFT = 0xB24BaB1732D34cAD0A7C7035C3539aEC553bF3a0;

    // ┌─────────────────────────┐
    // │        Constants        │
    // └─────────────────────────┘

    uint256 public constant MAX_SUPPLY = 4_440_000_000 ether; // 4.44B tokens
    uint256 public constant maxSupply = 4440; // nft maxSupply for uri hider
    uint256 public constant startTokenId = 1;
    uint256 private constant INITIAL_PRICE = 0.025 ether;   // Base price per 10M tokens
    uint256 private constant LIQUIDITY_RESERVE = MAX_SUPPLY * 10 / 100; // 10% reserve for liquidity

        // ┌─────────────┐
        // │  Tax Stuff  │
        // └─────────────┘

    uint256 private constant TAX_RATE = 400; // 4% tax
    uint256 private constant MIN_SELL_THRESHOLD = 12000 ether;    // 100 tokens minimum for sell
    uint256 private constant MIN_CULT_THRESHOLD = 8000 ether;    // 500 tokens minimum for CULT ops
    uint256 private constant MIN_LP_THRESHOLD = 4000 ether;     // 1000 tokens minimum for LP ops
    uint24 private constant POOL_FEE = 10000; // 1% fee tier
    
    int24 private constant TICK_SPACING = 60;

    // ┌─────────────────────────┐
    // │        Immutables       │
    // └─────────────────────────┘
    
    address private immutable factory;
    uint256 public immutable LAUNCH_TIME;

    // ┌─────────────────────────┐
    // │        Variables        │
    // └─────────────────────────┘
    
    // address private cultLiquidityPair;

    address public liquidityPair;
    bytes32[] private tierRoots;
    
    uint256 public totalBondingSupply;
    uint256 private reserve;

    address public cultPool;
    uint256 public cultV3Position;

    bool private swapping;
    mapping(uint256 => uint256) private blockSwaps;
    mapping(address => bool) public freeMint;
    uint256 public freeSupply = 1000 * 1000000 ether; //1000 free mints

    string public uri;
    string public unrevealedUri;
    bool public revealed = false;

    mapping(uint256 => BondingMessage) public bondingMessages;
    uint256 public totalMessages;

    // ┌─────────────────────────┐
    // │        Events           │
    // └─────────────────────────┘

    event WhitelistInitialized(bytes32[] roots);
    event V3FeesCollected(address indexed collector, uint256 amount0, uint256 amount1);
    event BondingSale(address indexed participant, uint256 amount, uint256 cost, bool isBuy);
    event LiquidityDeployed(uint256 amountToken, uint256 amountETH, uint256 liquidity);

    // ┌─────────────────────────┐
    // │        Modifiers        │
    // └─────────────────────────┘

    modifier whitelistGated(bytes32[] calldata proof) {
        require(liquidityPair == address(0), "Presale ended");
        uint256 currentTier = getCurrentTier();
        if (currentTier < tierRoots.length - 1) {
            require(isWhitelisted(proof, msg.sender), "Non-white");
        }
        _;
    }

// ┌───────────────────────────────────────────────┐
// │                CONSTRUCTOR                    │
// └───────────────────────────────────────────────┘

    constructor(
        bytes32[] memory _tierRoots
    ) {
        require(_tierRoots.length == 12, "Bad roots");
        
        tierRoots = _tierRoots;
        LAUNCH_TIME = block.timestamp;

        // Store router address in memory before assembly block
        address routerAddr = address(router);
        address factoryAddr;
        assembly {
            // Get factory address using factory() selector: 0xc45a0155
            mstore(0x00, 0xc45a015500000000000000000000000000000000000000000000000000000000)
            let success := staticcall(
                gas(),
                routerAddr,     // use local variable instead of immutable
                0x00,           // input offset
                0x04,           // input size (just selector)
                0x00,           // output offset
                0x20            // output size (32 bytes)
            )
            if iszero(success) {
                revert(0, 0)
            }
            factoryAddr := mload(0x00)  // store in temporary variable
        }
        factory = factoryAddr;  // assign to immutable after assembly block

        // Set CULT V3 pool directly
        (,bytes memory d) = factory3.staticcall(abi.encodeWithSelector(0x1698ee82, CULT, weth, POOL_FEE));
        cultPool = abi.decode(d, (address));
        require(cultPool != address(0), "no CULT");
        
        emit WhitelistInitialized(_tierRoots);
        address mirror = address(new DN404Mirror(msg.sender));
        _initializeDN404(MAX_SUPPLY, address(this), mirror);
    }

// ┌───────────────────────────────────────────────┐
// │             External Functions                │
// └───────────────────────────────────────────────┘

    /// @notice Allows users to buy tokens through the bonding curve mechanism
    /// @dev Only whitelisted addresses can call this function
    /// @param amount The amount of tokens to buy
    /// @param maxCost The maximum ETH cost the user is willing to pay
    /// @param mintNFT If true, will mint NFTs for the tokens. If false, keeps as ERC20
    /// @param proof The merkle proof to verify the caller is whitelisted
    /// @param message Optional message to store with the purchase
    function buyBonding(
        uint256 amount, 
        uint256 maxCost, 
        bool mintNFT, 
        bytes32[] calldata proof,
        string calldata message
    ) external payable whitelistGated(proof) {
        // Verify:
        // 1. Amount requested + current supply doesn't exceed max bonding supply (MAX_SUPPLY - LIQUIDITY_RESERVE)
        // 2. User's specified maxCost is >= actual cost calculated from bonding curve
        // 3. User sent enough ETH to cover the actual cost
        require(totalBondingSupply + amount <= MAX_SUPPLY - LIQUIDITY_RESERVE, "Exceeds bonding");
        uint256 totalCost = calculateCost(amount);
        require(maxCost >= totalCost, "MaxCost exceeded");
        require(msg.value >= totalCost, "Low ETH value");

        // Only flip skipNFT if it's currently true and user wants to mint
        bool originalSkipNFT = mintNFT ? getSkipNFT(msg.sender) : false;
        if (originalSkipNFT) {
            _setSkipNFT(msg.sender, false);
        }

        // Handle free mints if applicable
        if(freeSupply > 1000000 ether && !freeMint[msg.sender]) {
            totalBondingSupply += amount;
            amount += 1000000 ether;
            freeSupply -= 1000000 ether;
            freeMint[msg.sender] = true;
        } else {
            totalBondingSupply += amount;
        }

        // Transfer tokens from contract to user
        _transfer(address(this), msg.sender, amount);
        reserve += totalCost;

        // Store message if provided
        if (bytes(message).length > 0) {
            uint64 scaledAmount = uint64(amount / 1e18);
            require(scaledAmount <= type(uint64).max, "Too size for msg");
            
            bondingMessages[totalMessages++] = BondingMessage({
                sender: msg.sender,
                packedData: packData(
                    uint32(block.timestamp),
                    scaledAmount,
                    true  // isBuy
                ),
                message: message
            });
        }

        // Only flip back if we changed it
        if (originalSkipNFT) {
            _setSkipNFT(msg.sender, true);
        }

        // Return any excess ETH to user
        if (msg.value > totalCost) {
            SafeTransferLib.safeTransferETH(msg.sender, msg.value - totalCost);
        }

        emit BondingSale(msg.sender, amount, totalCost, true);
    }

    /// @notice Allows users to sell tokens back to the bonding curve
    /// @dev Requires whitelisting and prevents selling of free minted tokens
    /// @param amount The amount of tokens to sell back
    /// @param minRefund The minimum ETH refund amount expected
    /// @param proof Merkle proof for whitelist verification
    /// @param message Optional message to store with the sale
    /// @custom:tax 4% total tax (1% to operator, 3% to protocol)
    function sellBonding(
        uint256 amount, 
        uint256 minRefund, 
        bytes32[] calldata proof,
        string calldata message
    ) external whitelistGated(proof) {
        // Requirements for selling tokens back to bonding curve:
        // 1. User must have sufficient balance to sell the requested amount
        // 2. Users who received free tokens (freeMint) cannot sell below their initial 1M token allocation
        // 3. The calculated refund must meet the user's minimum expected refund amount
        // 4. The contract must have sufficient ETH reserves to process the refund
        uint256 balance = balanceOf(msg.sender);
        require(balance >= amount, "smolbalance");
        if(freeMint[msg.sender] && (balance - amount < 1000000 ether)) {
            revert("Cannot sell your freebie back into bonding");
        }
        // Calculate refund and validate
        uint256 refund = calculateRefund(amount);
        require(refund >= minRefund && reserve >= refund, "Invalid refund");

        // Transfer tokens first
        _transfer(msg.sender, address(this), amount);
        totalBondingSupply -= amount;
        reserve -= refund;

        // Store message if provided
        if (bytes(message).length > 0) {
            require(amount / 1 ether <= type(uint64).max, "Too size for msg");
            bondingMessages[totalMessages++] = BondingMessage({
                sender: msg.sender,
                packedData: packData(
                    uint32(block.timestamp),
                    uint64(amount  /  1 ether),
                    false  // isBuy
                ),
                message: message
            });
        }

        // Calculate and distribute refund with tax (4% total tax)
        // 1% to operator (25% of tax), 3% to protocol (75% of tax)
        uint256 userRefund = (refund * 9600) / 10000; // 96% to user
        SafeTransferLib.safeTransferETH(
            _erc721OwnerOf(OPERATOR_NFT, 598), 
            (refund * 100) / 10000  // 1% to operator
        );
        SafeTransferLib.safeTransferETH(msg.sender, userRefund);

        emit BondingSale(msg.sender, amount, refund, false);
    }

    /// @notice Allows a user to mint NFTs based on their token balance by temporarily storing excess tokens
    /// @dev DN404 mints NFTs when tokens are transferred and the recipient has skipNFT set to false.
    /// This function:
    /// 1. Calculates how many NFTs the user's balance can support
    /// 2. Temporarily stores excess tokens in the contract that shouldn't be minted
    /// 3. Sets skipNFT to false and triggers a self-transfer to mint the desired NFTs
    /// 4. Returns the stored tokens back to the user
    /// @param amount The number of NFTs to mint
    function balanceMint(uint256 amount) external {
        DN404Storage storage $ = _getDN404Storage();
        AddressData storage addressData = $.addressData[msg.sender];
        
        // Check if they have enough token balance to support the NFTs
        uint256 balance = addressData.balance;
        uint256 currentOwnedLength = addressData.ownedLength;
        uint256 maxMintPossible = balance / _unit() - currentOwnedLength;
        require(amount <= maxMintPossible, "NFTs over balance");

        // Calculate amounts
        uint256 amountToMint = amount * _unit();
        // Keep enough tokens to support existing NFTs plus new ones we want to mint
        uint256 amountToHold = balance - (currentOwnedLength + amount) * _unit();
        
        // First transfer the portion we don't want to mint to the contract
        _transfer(msg.sender, address(this), amountToHold);
        
        // Set skipNFT false for minting
        bool originalSkipNFT = getSkipNFT(msg.sender);
        _setSkipNFT(msg.sender, false);
        
        // Self-transfer to trigger mint
        _transfer(msg.sender, msg.sender, amountToMint);
        
        // Reset skipNFT
        _setSkipNFT(msg.sender, originalSkipNFT);
        
        // Return held tokens
        _transfer(address(this), msg.sender, amountToHold);
        
        // Verify final state
        require(addressData.balance == balance);
        require(addressData.ownedLength == currentOwnedLength + amount);
    }

    /// @notice Deploys initial liquidity to Uniswap V2 and V3 pools after whitelist period ends
    /// @dev This function:
    /// - Can only be called once after 12 hours from launch time
    /// - Creates a V2 pair with WETH and deploys liquidity using remaining token supply
    /// - Sets aside 0.01 ETH to initialize CULT pool
    /// - Stores the V2 pair address for future use
    /// - Attempts to initialize CULT pool with remaining ETH
    /// @return amountToken The amount of tokens added to V2 liquidity
    /// @return amountETH The amount of ETH added to V2 liquidity  
    /// @return liquidity The amount of V2 LP tokens received
    function deployLiquidity() external returns (uint256 amountToken, uint256 amountETH, uint256 liquidity) {
        // For liquidity deployment to succeed:
        // 1. Must be at least 12 hours after launch time (LAUNCH_TIME)
        // 2. Liquidity pair must not already be deployed (liquidityPair must be address(0))
        // 3. Contract must have more than 0.01 ETH balance to deploy
        // 4. Must have remaining tokens available to deploy, calculated as:
        //    MAX_SUPPLY - (totalBondingSupply + (1000000000 ether - freeSupply))
        //    where 1000000000 ether represents total supply and freeSupply is available supply
        require(block.timestamp >= LAUNCH_TIME + 12 hours, "Too early for liq");
        require(liquidityPair == address(0), "Liq already deployed!");
        
        uint256 ethBalance = address(this).balance;
        require(ethBalance > 0.01 ether, "No ETH to deploy");

        uint256 remainingSupply = MAX_SUPPLY - (totalBondingSupply + (1000000000 ether - freeSupply));
        require(remainingSupply > 0, "No tokens to deploy");

        // Create and store the pair address
        (,bytes memory d) = factory.call(abi.encodeWithSelector(0xc9c65396, address(this), weth));
        liquidityPair = abi.decode(d, (address));

        // Set aside small amount for CULT pool initialization
        uint256 ethForCult = 0.005 ether;
        uint256 ethForOperations = 0.01 ether;
        uint256 ethForV2 = ethBalance - ethForCult - ethForOperations;

        // Deploy V2 liquidity first
        _approve(address(this), address(router), remainingSupply);

        // Assembly block that replaces a low-level call to the V2 router interface function:
        // addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline)
        // Returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)
        assembly {
            // Get free memory pointer for our calldata
            let ptr := mload(0x40)
            
            // Store the function selector for addLiquidityETH(address,uint256,uint256,uint256,address,uint256)
            mstore(ptr, 0xf305d71900000000000000000000000000000000000000000000000000000000)
            
            // Pack the 6 parameters into calldata:
            mstore(add(ptr, 0x04), address())          // param1: token - address of this contract
            mstore(add(ptr, 0x24), remainingSupply)    // param2: amountTokenDesired - remaining tokens for liquidity
            mstore(add(ptr, 0x44), 0)                  // param3: amountTokenMin - accept any amount (0)
            mstore(add(ptr, 0x64), 0)                  // param4: amountETHMin - accept any amount (0) 
            mstore(add(ptr, 0x84), address())          // param5: to - send LP tokens to this contract
            mstore(add(ptr, 0xa4), timestamp())        // param6: deadline - current block timestamp

            // Call the router contract's addLiquidityETH function
            let success := call(
                gas(),          // Forward all gas
                router,         // Address of router contract
                ethForV2,       // Send ethForV2 amount of ETH with call
                ptr,            // Pointer to start of input (calldata)
                0xc4,           // Input size = 4 (selector) + 6 * 32 (params) = 196 bytes
                ptr,            // Store output at same memory location
                0x60            // Output size = 3 * 32 = 96 bytes (three uint256 return values)
            )

            // If call failed, copy error data and revert
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, 0)
            }

            // Store the three return values in their respective variables:
            amountToken := mload(ptr)          // amount of tokens actually sent
            amountETH := mload(add(ptr, 0x20)) // amount of ETH actually sent
            liquidity := mload(add(ptr, 0x40)) // amount of LP tokens received
        }

        // Try to initialize CULT pool with remaining ETH
        if (!_initializeCultPoolLogic()) {
            // If initialization fails, check if we already have a position
            // If we do, that's fine - continue. If not, then revert
            require(cultV3Position != 0);
        }

        return (amountToken, amountETH, liquidity);
        emit LiquidityDeployed(amountToken, amountETH, liquidity);
    }

// ┌─────────────────────────┐
// │      Operator Only      │
// └─────────────────────────┘

    /// @notice Collects fees from the V3 liquidity position
    /// @dev Only callable by the owner of OPERATOR_TOKEN_ID
    /// @param amount0Max The maximum amount of token0 to collect
    /// @param amount1Max The maximum amount of token1 to collect
    /// @return amount0 The amount of token0 collected
    /// @return amount1 The amount of token1 collected
    function collectV3Fees(uint128 amount0Max, uint128 amount1Max) external payable returns (uint256 amount0, uint256 amount1) {
        // Check if caller owns the operator token
        require(_erc721OwnerOf(OPERATOR_NFT, 598) == msg.sender, "Not oper");
        
        // Require at least one amount to be non-zero (matching V3 requirement)
        require(amount0Max > 0 || amount1Max > 0, "Amount0Max and amount1Max both 0");
    
        // Assembly block that replaces a low-level call to the INonfungiblePositionManager interface function:
        // collect(INonfungiblePositionManager.CollectParams memory params) external payable returns (uint256 amount0, uint256 amount1)
        uint256 _cultPosition = cultV3Position;
        assembly {
            // collect function selector: 0xfc6f7865
            let ptr := mload(0x40)
            mstore(ptr, 0xfc6f786500000000000000000000000000000000000000000000000000000000)
            
            // Pack parameters
            mstore(add(ptr, 0x04), _cultPosition)   // tokenId
            mstore(add(ptr, 0x24), caller())        // recipient
            mstore(add(ptr, 0x44), amount0Max)      // amount0Max
            mstore(add(ptr, 0x64), amount1Max)      // amount1Max

            // Make the call
            let success := call(
                gas(),
                positionManager,  // target
                callvalue(),      // forward any ETH value
                ptr,             // input
                0x84,           // input size (4 + 4 * 32)
                ptr,            // output
                0x40            // output size (2 * 32 for two uint256 returns)
            )

            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, 0)
            }

            // Load return values
            amount0 := mload(ptr)
            amount1 := mload(add(ptr, 0x20))
        }
        
        emit V3FeesCollected(msg.sender, amount0, amount1);
    }

    /// @notice Updates the token URI configuration for revealed and unrevealed states
    /// @dev Only callable by the owner of OPERATOR_NFT token ID 1
    /// @param _uri The new base URI for revealed tokens
    /// @param _unrevealedUri The new URI for unrevealed tokens
    /// @param _revealed Whether tokens should be revealed or not
    function configure(string memory _uri, string memory _unrevealedUri, bool _revealed) public {
        require(_erc721OwnerOf(OPERATOR_NFT, 598) == msg.sender, "not oper");
        uri = _uri;
        unrevealedUri = _unrevealedUri;
        revealed = _revealed;
    }

    /// @notice Failsafe function to initialize the CULT liquidity pool if automatic initialization fails
    /// @dev This function can be called manually to retry pool initialization if the automatic process fails
    /// @dev The function requires ETH to be sent with the call to provide initial liquidity
    /// @dev Will revert if pool is already initialized or if initialization fails
    function initializeCultPool() external payable {
        require(_initializeCultPoolLogic(), "Pool init failed");
    }

    /// @dev Override receive to accept ETH transfers
    receive() external payable override {
    // Accept ETH transfers silently
    }

    /// @notice Callback function for Uniswap V3 swaps that allows buying CULT tokens
    /// @dev This function is called by the Uniswap V3 pool during a swap operation
    /// @dev It verifies the caller is the authorized CULT pool and handles token transfers
    /// @dev For positive amount0Delta, transfers token0 to pool. For positive amount1Delta, transfers token1 to pool
    /// @param amount0Delta The change in token0 balance that needs to be paid for
    /// @param amount1Delta The change in token1 balance that needs to be paid for
    /// data param not used
    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata /* data */
    ) external override {
        assembly {
            // First, verify the caller is our expected CULT pool
            // This is a security check to ensure only our authorized pool can trigger this callback
            let sender := caller()
            if iszero(eq(sender, sload(cultPool.slot))) {
                // If not authorized, revert with "Unauthed pool" message
                mstore(0x00, 0x20)        // String offset
                mstore(0x20, 0x0e)        // String length (14 bytes)
                mstore(0x40, "Unauthed pool")
                revert(0x00, 0x4e)        // Revert with error message
            }

            // Get token0 address from the pool using token0() function
            // Function selector for token0(): 0x0dfe1681
            mstore(0x00, 0x0dfe168100000000000000000000000000000000000000000000000000000000)
            if iszero(staticcall(gas(), sender, 0x00, 0x04, 0x00, 0x20)) {
                revert(0, 0)
            }
            let token0 := mload(0x00)

            // Get token1 address from the pool using token1() function
            // Function selector for token1(): 0xd21220a7  
            mstore(0x00, 0xd21220a700000000000000000000000000000000000000000000000000000000)
            if iszero(staticcall(gas(), sender, 0x00, 0x04, 0x00, 0x20)) {
                revert(0, 0)
            }
            let token1 := mload(0x00)

            // Prepare ERC20 transfer call data
            // Function selector for transfer(address,uint256): 0xa9059cbb
            mstore(0x00, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
            mstore(0x04, sender)          // First parameter: recipient (pool address)

            // If amount0Delta is positive, we need to send token0 to the pool
            if sgt(amount0Delta, 0) {
                mstore(0x24, amount0Delta) // Second parameter: amount to transfer
                // Execute transfer of token0
                pop(call(gas(), token0, 0, 0x00, 0x44, 0x00, 0x00))
            }

            // If amount1Delta is positive, we need to send token1 to the pool
            if sgt(amount1Delta, 0) {
                mstore(0x24, amount1Delta) // Second parameter: amount to transfer
                // Execute transfer of token1
                pop(call(gas(), token1, 0, 0x00, 0x44, 0x00, 0x00))
            }
        }
    }

    /// @notice Handles ERC721 token transfers
    /// @dev This function is called when an ERC721 token is transferred to this contract
    /// @dev It returns the selector for the onERC721Received function
    /// @dev necessary to receive v3 liquidity position NFTs
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return 0x150b7a02; // IERC721Receiver.onERC721Received.selector
    }

    /// @notice Gets the details of a specific bonding message
    /// @dev Unpacks the message data from the packed storage format
    /// @param messageId The ID of the message to retrieve
    /// @return sender The address that created the message
    /// @return timestamp The timestamp when the message was created
    /// @return amount The token amount involved in the transaction
    /// @return isBuy Whether the message was from a buy (true) or sell (false)
    /// @return message The text content of the message
    function getMessageDetails(uint256 messageId) external view returns (
        address sender,
        uint32 timestamp,
        uint96 amount,
        bool isBuy,
        string memory message
    ) {
        require(messageId < totalMessages, "Msg doesnt exist");
        BondingMessage memory bondingMsg = bondingMessages[messageId];  // Changed variable name to avoid shadowing
        (timestamp, amount, isBuy) = unpackData(bondingMsg.packedData);
        return (bondingMsg.sender, timestamp, amount, isBuy, bondingMsg.message);
    }

    /// @notice Retrieves a batch of bonding messages between specified indices
    /// @dev Efficiently fetches multiple messages in a single call to reduce gas costs
    /// @param start The starting index of messages to retrieve (inclusive)
    /// @param end The ending index of messages to retrieve (inclusive) 
    /// @return senders Array of addresses that created the messages
    /// @return timestamps Array of timestamps when messages were created
    /// @return amounts Array of token amounts involved in each transaction
    /// @return isBuys Array of booleans indicating if each message was from a buy (true) or sell (false)
    /// @return messages Array of message text contents
    function getMessagesBatch(uint256 start, uint256 end) external view returns (
        address[] memory senders,
        uint32[] memory timestamps,
        uint96[] memory amounts,
        bool[] memory isBuys,
        string[] memory messages
    ) {
        require(end >= start, "Invalid range");
        require(end < totalMessages, "End out of bounds");
        
        uint256 size = end - start + 1;
        senders = new address[](size);
        timestamps = new uint32[](size);
        amounts = new uint96[](size);
        isBuys = new bool[](size);
        messages = new string[](size);
        
        for (uint256 i = 0; i < size; i++) {
            BondingMessage memory bondingMsg = bondingMessages[start + i];  // Changed variable name to avoid shadowing
            senders[i] = bondingMsg.sender;
            (timestamps[i], amounts[i], isBuys[i]) = unpackData(bondingMsg.packedData);
            messages[i] = bondingMsg.message;
        }
    }


// ┌───────────────────────────────────────────────┐
// │              PUBLIC FUNCTIONS                 │
// └───────────────────────────────────────────────┘

    /// @notice The transfer and transferFrom functions implement the Wankel Tax system
    /// @dev When tokens are transferred to/from the liquidity pool, a tax is applied
    /// The tax is collected by the contract and later converted to liquidity for $CULT
    /// This creates a positive feedback loop where trading activity strengthens the liquidity
    /// The tax rate is set via TAX_RATE constant (in basis points)
    /// Tax is not applied to:
    /// - Transfers before liquidity pair is set
    /// - Transfers involving the contract itself
    /// - Regular P2P transfers between users

    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        // First calculate the tax amount
        uint256 taxAmount = amount - _beforeTransfer(msg.sender, to, amount);
        
        _processTaxes(msg.sender, to);

        // Finally perform the transfers
        if (taxAmount > 0) {
            _transfer(msg.sender, address(this), taxAmount);
        }
        _transfer(msg.sender, to, amount - taxAmount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {

        // Calculate tax and perform transfers
        uint256 taxAmount = amount - _beforeTransfer(from, to, amount);
        
        _processTaxes(from, to);

        if (taxAmount > 0) {
            _transfer(from, address(this), taxAmount);
        }
        return super.transferFrom(from, to, amount - taxAmount);
    }


// ┌───────────────────────────────────────────────┐
// │              INTERNAL FUNCTIONS               │
// └───────────────────────────────────────────────┘


    /// @notice Internal function to handle tax logic for transfers
    /// @dev Checks if a transfer involves the liquidity pool and applies the tax rate if so
    /// @param from The sender address
    /// @param to The recipient address 
    /// @param amount The transfer amount
    /// @return The final transfer amount after any applicable tax deduction
    function _beforeTransfer(address from, address to, uint256 amount) internal view returns (uint256) {
        // Don't tax if liquidity pair isn't set yet (initial deployment)
        address liq = liquidityPair;
        if (liq == address(0)) return amount;
        
        // Don't tax if contract is involved in the transfer
        if (from == address(this) || to == address(this)) return amount;
        
        // Apply tax on liquidity pair interactions
        if (to == liq || from == liq) {
            // uint256 taxAmount = (amount * TAX_RATE) / 10000;
            // return amount - taxAmount;
            assembly {
                // amount - ((amount * TAX_RATE) / 10000)
                let tax := div(mul(amount, TAX_RATE), 10000)
                amount := sub(amount, tax)
            }
        }
        return amount;
    }

    // ┌─────────────────────────┐
    // │     DN404 Overrides     │
    // └─────────────────────────┘

    /// @notice Returns the number of tokens that correspond to one NFT
    /// @dev Each NFT represents 1,000,000 $EXEC tokens (1M tokens = 1 NFT)
    /// @return The number of tokens per NFT (1,000,000 * 10^18)
    function _unit() internal pure override returns (uint256) {
        return 1000000 * 10 ** 18;
    }

    /// @notice Returns the token URI for a given token ID
    /// @dev If the token does not exist or is not revealed, returns the unrevealed URI
    /// @param tokenId The ID of the token to get the URI for
    /// @return The token URI as a string
    function _tokenURI(uint256 tokenId) internal view override returns (string memory) {
        // return "https://example.com/token/1";
        if (!_exists(tokenId) || !revealed) {
            return unrevealedUri;
        }
        return bytes(uri).length != 0 ? string(abi.encodePacked(uri, LibString.concat(_toString(tokenId),".json"))) : "test";
    }

    /// @dev Override to set skip NFT default to On (true)
    /// @return SkipNFTDefault.On
    function _skipNFTDefault() internal pure override returns (SkipNFTDefault) {
        return SkipNFTDefault.On;
    }

    // ┌─────────────────────────┐
    // │   Wankel Tax System ♺   │
    // └─────────────────────────┘

    /**
     * @notice The Wankel Tax System, inspired by the rotary engine's tri-chamber design
     * @dev A three-phase tax recycling system that:
     *      1. Sells accumulated $EXEC tokens (compression)
     *      2. Buys $CULT with ETH proceeds (combustion) 
     *      3. Adds liquidity to UniswapV3 position (exhaust)
     *
     * Like the Wankel engine's continuous rotary motion, this system
     * maintains constant pressure under the V2 liquidity pool by
     * churning volume through its three distinct phases. Each phase
     * triggers automatically based on accumulated token thresholds.
     */

     /**
     * @notice Core tax processing function that drives the Wankel Tax System
     * @dev Executes the three-phase tax recycling system on token sells:
     *      1. Selling EXEC tokens when accumulated (compression phase)
     *      2. Buying CULT with ETH proceeds (combustion phase)
     *      3. Adding liquidity to UniswapV3 (exhaust phase)
     *
     * This function acts as the central coordinator, checking balances and
     * conditions before selecting and executing the appropriate tax operation.
     * It maintains system pressure by limiting operations to 3 per block and
     * prevents recursive calls via the swapping flag.
     *
     * @param from Address tokens are being transferred from
     * @param to Address tokens are being transferred to
     */
    function _processTaxes(address from, address to) internal {
        // Skip if pair isn't initialized yet (for initial liquidity)
        address liq = liquidityPair;
        if (liq == address(0)) return;
        if (from == address(this) || to == address(this)) return;
        // Only process on sells (when transferring TO the pair)
        uint256 blockSwap = blockSwaps[block.number];
        bool isSell = to == liq;
        if (isSell && !swapping && blockSwap < 3) {
            uint256 execBalance = balanceOf(address(this));
            if (execBalance >= MIN_SELL_THRESHOLD) {
                swapping = true;
                uint256 ethBalance = address(this).balance;
                uint256 cultBalance = _erc20BalanceOf(CULT,address(this));
                (uint8 operation, uint256 amount) = _selectOperation(ethBalance,cultBalance,execBalance);
                if (operation == 0) {
                    _sellExecTax(execBalance);
                } else if (operation == 1) {
                    _buyCultWithExactEth(amount);
                } else {
                    //_handleAddCultLiquidity(ethBalance, cultBalance);
                    _increaseCultLiquidity(cultBalance, ethBalance);
                }
                swapping = false;
                blockSwaps[block.number] = blockSwap + 1;
            }
        }
    }

    /**
     * @notice Determines the next tax operation based on current token balances
     * @dev Part of the Wankel Tax System that selects between selling EXEC, buying CULT, or adding liquidity
     * @param ethBalance The current ETH balance of the contract
     * @param cultBalance The current CULT token balance of the contract  
     * @param execBalance The current EXEC token balance of the contract
     * @return operation The selected operation (0 = sell EXEC, 1 = buy CULT, 2 = add liquidity)
     * @return amount The amount of tokens to use in the operation
     */
    function _selectOperation(uint256 ethBalance, uint256 cultBalance, uint256 execBalance) internal view returns (uint8 operation, uint256 amount) {

        // Priority 1: If we have EXEC and low ETH, sell EXEC
        if (execBalance >= MIN_SELL_THRESHOLD && ethBalance < 0.01 ether) {
            return (0, execBalance);
        }

        // Priority 2: If we have ETH but low CULT, buy CULT with ALL available ETH
        if (ethBalance >= 0.01 ether && cultBalance < MIN_CULT_THRESHOLD) {
            // Use ALL available ETH (minus gas buffer)
            uint256 ethToUse = ethBalance - 0.005 ether; // Leave 0.005 ETH for gas
            
            return (1, ethToUse);
        }

        // Priority 3: If we have both ETH and CULT, add ALL liquidity
        if (ethBalance >= 0.01 ether && cultBalance >= MIN_LP_THRESHOLD) {
            // Get optimal ratio for our ETH
            (uint256 optimalCult,) = _getOptimalCultRatio(ethBalance);
            // Use the maximum amount possible while maintaining ratio
            uint256 cultToUse = cultBalance > optimalCult ? optimalCult : cultBalance;
            return (2, cultToUse);
        }
        //fallback return
        return (0, 0);
    }

    function _sellExecTax(uint256 tokenBalance) internal {
        if (tokenBalance < MIN_SELL_THRESHOLD) return;

        _approve(address(this), address(router), tokenBalance);

        //Assembly veresion of v2 UniswapRouter interface function
        //swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)
        assembly {
            let ptr := mload(0x40)
            // Store function selector for swapExactTokensForETHSupportingFeeOnTransferTokens
            mstore(ptr, 0x791ac94700000000000000000000000000000000000000000000000000000000)
            // Store amountIn parameter (tokenBalance)
            mstore(add(ptr, 0x04), tokenBalance)
            // Store amountOutMin parameter (0 for no minimum)
            mstore(add(ptr, 0x24), 0)              
            // Store path array offset (points to 0xa0 where array data begins)
            mstore(add(ptr, 0x44), 0xa0)          
            // Store recipient address (this contract)
            mstore(add(ptr, 0x64), address())     
            // Store deadline (block.timestamp)
            mstore(add(ptr, 0x84), timestamp())   
            // Store path array length (2 elements)        
            mstore(add(ptr, 0xa4), 2)            
            // Store first path address (this contract)
            mstore(add(ptr, 0xc4), address())    
            // Store second path address (WETH)
            mstore(add(ptr, 0xe4), weth)  
            // Make external call to router contract
            let success := call(
                gas(),
                router,//mainnet
                0,              // No ETH sent
                ptr,           // Input data pointer
                0x104,         // Input data size (260 bytes)
                0,             // Output data pointer 
                0              // Output data size
            )
            // Revert on failure and forward error message
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }

    /// @notice Swaps ETH for CULT tokens using Uniswap V3 pool
    /// @dev Deposits ETH as WETH, approves pool, and executes swap using assembly for gas optimization (and bytecode size reduction)
    /// @param ethAmount The amount of ETH to swap for CULT
    /// @return cultBought The amount of CULT tokens received from the swap
    function _buyCultWithExactEth(uint256 ethAmount) internal returns (uint256 cultBought) {
        
        _wethDeposit(ethAmount);
        address pool = cultPool;
        _erc20Approve(weth, pool, ethAmount);
        
        bool zeroForOne = weth < CULT; // true if WETH is token0
        //bytes memory data = ""; // No callback needed

        //Assembly version of Uniswap V3 Pool swap function
        //Interface: swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data)
        uint256 result;
        assembly {
            // Get free memory pointer
            let ptr := mload(0x40)

            // Store function selector for swap()
            mstore(ptr, 0x128acb0800000000000000000000000000000000000000000000000000000000)
            
            // Store recipient address (this contract)
            mstore(add(ptr, 0x04), address())
            
            // Store zeroForOne bool (true if WETH is token0)
            // Double negation ensures proper boolean value
            mstore(add(ptr, 0x24), iszero(iszero(zeroForOne)))
            
            // Store amountSpecified (ethAmount as int256)
            mstore(add(ptr, 0x44), ethAmount)

            // Store sqrtPriceLimitX96 based on direction
            // If zeroForOne: use min price + 1 (4295128740)
            // If oneForZero: use max price - 1 (1461446703485210103287273052203988822378723970341)
            switch zeroForOne
            case 1 {
                mstore(add(ptr, 0x64), 4295128740)
            }
            default {
                mstore(add(ptr, 0x64), 1461446703485210103287273052203988822378723970341)
            }

            // Store empty bytes data
            // First word is offset (0xa0)
            mstore(add(ptr, 0x84), 0xa0)
            // Second word is length (0)
            mstore(add(ptr, 0xa4), 0)

            // Make external call to pool contract
            let callSuccess := call(
                gas(),          // Forward all gas
                pool,          // Target contract (Uniswap V3 pool)
                0,             // No ETH sent
                ptr,           // Input data pointer
                0xc4,          // Input size (196 bytes)
                ptr,           // Output data pointer
                0x40           // Output size (64 bytes for two int256)
            )

            // On successful swap
            if callSuccess {
                // Load returned amounts
                let amount0 := mload(ptr)         // First returned int256
                let amount1 := mload(add(ptr, 0x20)) // Second returned int256

                // Calculate result based on swap direction
                // We negate the relevant amount since V3 returns negative for tokens received
                switch zeroForOne
                case 1 {
                    result := sub(0, amount1)  // Use amount1 if WETH is token0
                }
                default {
                    result := sub(0, amount0)  // Use amount0 if WETH is token1
                }
            }

            // On failed swap
            if iszero(callSuccess) {
                // Withdraw WETH by calling withdraw(uint256)
                mstore(0x00, 0x2e1a7d4d)      // withdraw() selector
                mstore(0x04, ethAmount)       // amount to withdraw
                pop(call(gas(), weth, 0, 0x00, 0x24, 0x00, 0x00))
                result := 0
            }
        }
        cultBought = result;
    }

    /// @notice Calculates the optimal amount of CULT tokens needed for a given ETH amount based on current pool price
    /// @dev Uses the Uniswap V3 pool's current sqrt price to determine the ideal ratio for liquidity provision
    /// @dev The calculation is: optimalCult = ethAmount * price / 1e18, where price = (sqrtPriceX96^2 * 1e18) >> 192
    /// @param ethAmount The amount of ETH to calculate the ratio for
    /// @return optimalCult The optimal amount of CULT tokens needed
    /// @return price The current price of CULT in terms of ETH (scaled by 1e18)
    function _getOptimalCultRatio(uint256 ethAmount) internal view returns (uint256 optimalCult, uint256 price) {
        (uint160 sqrtPriceX96,) = _staticcallSlot0Values(cultPool);

        assembly {
            // Calculate price = (sqrtPriceX96 * sqrtPriceX96 * 1e18) >> 192
            let priceX96 := mul(sqrtPriceX96, sqrtPriceX96)
            price := shr(192, mul(priceX96, exp(10, 18)))
            
            // Calculate optimalCult = (ethAmount * price) / 1e18
            optimalCult := div(mul(ethAmount, price), exp(10, 18))
        }
    }

    function _increaseCultLiquidity(uint256 cultBalance, uint256 ethBalance) internal returns (bool success) {

        if (cultBalance == 0 || ethBalance < 0.01 ether) {
            return false;
        }

        if (cultV3Position == 0) {
            return false;
        }

        // Use everything except gas buffer
        uint256 ethAmount = ethBalance - 0.01 ether;

        if (ethAmount < 0.01 ether) {
            return false;
        }

        _wethDeposit(ethAmount);
        
        _erc20Approve(CULT, address(positionManager), cultBalance);
        _erc20Approve(weth, address(positionManager), ethAmount);

        // Store immutable values in memory before assembly block
        address posAddr = address(positionManager);
        //bool isToken0 = CULT < weth;
        // CULT < WETH CONFIRMED
        assembly {
            // Prepare calldata for increaseLiquidity
            let ptr := mload(0x40)
            
            // Interface: function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1)
            // Where IncreaseLiquidityParams is:
            // struct IncreaseLiquidityParams {
            //     uint256 tokenId;           // The ID of the NFT position to increase liquidity for
            //     uint256 amount0Desired;    // The desired amount of token0 to be spent
            //     uint256 amount1Desired;    // The desired amount of token1 to be spent
            //     uint256 amount0Min;        // The minimum amount of token0 to spend
            //     uint256 amount1Min;        // The minimum amount of token1 to spend
            //     uint256 deadline;          // The time by which the transaction must be included
            // }
            
            // Function selector for increaseLiquidity
            mstore(ptr, 0x219f5d1700000000000000000000000000000000000000000000000000000000)
            
            // Store tokenId parameter
            mstore(add(ptr, 0x04), sload(cultV3Position.slot))
            
            // Store amount0Desired and amount1Desired based on token ordering
            mstore(add(ptr, 0x24), cultBalance)  // amount0Desired = cultBalance
            mstore(add(ptr, 0x44), ethAmount)   // amount1Desired = ethAmount
            
            // Store amount0Min and amount1Min as 0 (no minimum amounts required)
            mstore(add(ptr, 0x64), 0)  // amount0Min = 0
            mstore(add(ptr, 0x84), 0)  // amount1Min = 0
            
            // Store deadline as current block timestamp
            mstore(add(ptr, 0xa4), timestamp())

            // Make the call to increaseLiquidity
            let callSuccess := call(
                gas(),
                posAddr,  // position manager address
                0,      // no ETH sent
                ptr,    // calldata pointer
                0xc4,   // calldata size (4 + 6 * 32)
                0,      // output offset (ignore return values)
                0       // output size (ignore return values)
            )

            // On success, handle any unused WETH
            if callSuccess {
                // Interface: function balanceOf(address account) external view returns (uint256)
                let wethPtr := mload(0x40)
                mstore(wethPtr, 0x70a0823100000000000000000000000000000000000000000000000000000000)
                mstore(add(wethPtr, 0x04), address())
                
                // Check remaining WETH balance
                pop(staticcall(
                    gas(),
                    weth,
                    wethPtr,
                    0x24,  // input size (4 + 32)
                    0,     // output offset
                    0x20   // output size (32 bytes)
                ))
                
                let unusedWeth := mload(0)
                if gt(unusedWeth, 0) {
                    // Interface: function withdraw(uint256 wad) external
                    mstore(wethPtr, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                    mstore(add(wethPtr, 0x04), unusedWeth)
                    pop(call(gas(), weth, 0, wethPtr, 0x24, 0, 0))
                }
                
                success := 1
            }
            
            // On failure, withdraw all WETH
            // Interface: function withdraw(uint256 wad) external
            let wethPtr := mload(0x40)
            mstore(wethPtr, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
            mstore(add(wethPtr, 0x04), ethAmount)
            pop(call(gas(), weth, 0, wethPtr, 0x24, 0, 0))
            
            success := 0
        }

        return success;
    }

    // ┌─────────────────────────┐
    // │    Low Level Calls      │
    // └─────────────────────────┘

    // ┌───────────┐
    // │   erc20   │
    // └───────────┘

    /**
     * @notice Low level call to ERC20 approve function
     * @dev Uses assembly to make a direct call to the token's approve function
     *      Reverts if the call fails, bubbling up any error message
     * @param token The address of the ERC20 token contract
     * @param spender The address being approved to spend tokens
     * @param amount The amount of tokens being approved
     */
    function _erc20Approve(address token, address spender, uint256 amount) internal {
        assembly {
            let ptr := mload(0x40) // get free memory pointer
            
            // keccak256("approve(address,uint256)") = 0x095ea7b3...
            mstore(ptr, 0x095ea7b300000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x04), and(spender, 0xffffffffffffffffffffffffffffffffffffffff))
            mstore(add(ptr, 0x24), amount)
            
            let success := call(
                gas(),    // gas
                token,    // to
                0,       // value
                ptr,     // input offset
                0x44,    // input size (4 + 32 + 32)
                0,       // output offset
                0        // output size
            )
            // If call fails, bubble up the revert
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }

    /**
     * @notice Low level call to ERC20 balanceOf function
     * @dev Uses assembly to make a direct staticcall to the token's balanceOf function
     *      This optimizes bytecode size by avoiding ABI encoding/decoding
     *      Reverts if the call fails
     * @param token The address of the ERC20 token contract to query
     * @param account The address to check the balance of
     * @return result The token balance of the account
     */
    function _erc20BalanceOf(address token, address account) internal view returns (uint256 result) {
        assembly {
            // Store the function selector and argument in memory
            mstore(0x00, 0x70a0823100000000000000000000000000000000000000000000000000000000)
            mstore(0x04, and(account, 0xffffffffffffffffffffffffffffffffffffffff))
            
            // Perform the staticcall
            let success := staticcall(
                gas(),    // gas
                token,    // to
                0x00,    // input offset
                0x24,    // input size (4 + 32)
                0x00,    // output offset
                0x20     // output size (32 bytes)
            )
            
            // Check if the call was successful
            if iszero(success) {
                revert(0, 0)
            }

            // Return value is already in memory at 0x00, load it to the named return variable
            result := mload(0x00)
        }
    }

    /**
     * @notice Low level call to ERC20 transfer function
     * @dev Uses assembly to make a direct call to the token's transfer function
     *      Reverts if the call fails, bubbling up any error message
     * @param token The address of the ERC20 token contract
     * @param to The address to transfer the tokens to
     * @param amount The amount of tokens to transfer
     */
    function _erc20Transfer(address token, address to, uint256 amount) internal {
        assembly {
            let ptr := mload(0x40)

            // Function selector for transfer(address,uint256)
            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)
            mstore(add(ptr, 0x04), and(to, 0xffffffffffffffffffffffffffffffffffffffff))
            mstore(add(ptr, 0x24), amount)

            let success := call(
                gas(),
                token,
                0,
                ptr,
                0x44,  // input length = 4 + 32 + 32
                ptr,   // Store output in the same location
                0x20   // Expect 32 bytes (bool) return
            )

            // Check both call success and returned boolean
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
            
            // Load the returned boolean
            let returnValue := mload(ptr)
            if iszero(returnValue) {
                revert(0, 0)
            }
        }
    }

    // ┌───────────┐
    // │  erc721   │
    // └───────────┘

    /**
     * @notice Low level call to ERC721 ownerOf function
     * @dev Uses assembly to make a direct staticcall to the token's ownerOf function
     *      This optimizes bytecode size by avoiding ABI encoding/decoding
     *      Reverts if the call fails
     * @param collection The address of the ERC721 token contract
     * @param tokenId The ID of the token to check ownership of
     * @return owner The address of the token owner
     */
    function _erc721OwnerOf(address collection, uint256 tokenId) internal view returns (address owner) {
        assembly {
            // Store the function selector and argument in memory
            // keccak256("ownerOf(uint256)") = 0x6352211e
            mstore(0x00, 0x6352211e00000000000000000000000000000000000000000000000000000000)
            mstore(0x04, tokenId)
            
            // Perform the staticcall
            let success := staticcall(
                gas(),          // gas
                collection,     // to
                0x00,          // input offset
                0x24,          // input size (4 + 32)
                0x00,          // output offset
                0x20           // output size (32 bytes)
            )
            
            // Check if the call was successful
            if iszero(success) {
                revert(0, 0)
            }

            // Load the owner address from memory
            // Note: We mask the upper bits to ensure it's a valid address
            owner := and(mload(0x00), 0xffffffffffffffffffffffffffffffffffffffff)
        }
    }

    // ┌───────────┐
    // │  weth     │
    // └───────────┘

    /**
     * @notice Low level call to WETH deposit function
     * @dev Uses assembly to make a direct call to the WETH contract's deposit function
     *      Reverts if the call fails, bubbling up any error message
     * @param amount The amount of ETH to wrap in WETH
     * return not used
     */
    
    function _wethDeposit(uint256 amount) internal {
        assembly {
            // deposit() selector = 0xd0e30db0
            mstore(0x00, 0xd0e30db000000000000000000000000000000000000000000000000000000000)
            
            let success := call(
                gas(),    // gas
                weth,    // to
                amount,  // value (ETH to wrap)
                0x00,    // input offset
                0x04,    // input size (just selector)
                0x00,    // output offset
                0x00     // output size
            )
            
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }

    /**
     * @notice Low level call to WETH withdraw function
     * @dev Uses assembly to make a direct call to the WETH contract's withdraw function
     *      Reverts if the call fails, bubbling up any error message
     * @param amount The amount of WETH to withdraw
     * return not used
     */
    
    function _wethWithdraw(uint256 amount) internal {
        assembly {
            // withdraw(uint256) selector = 0x2e1a7d4d
            mstore(0x00, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
            mstore(0x04, amount)
            
            let success := call(
                gas(),    // gas
                weth,    // to
                0,       // value
                0x00,    // input offset
                0x24,    // input size (4 + 32)
                0x00,    // output offset
                0x00     // output size
            )
            
            if iszero(success) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }

    // ┌───────────┐
    // │  V3 Pool  │
    // └───────────┘

    /// @notice Reads sqrtPriceX96 and tick from a Uniswap V3 pool using a static call
    /// @param pool The address of the V3 pool
    /// @return sqrtPriceX96 The current price as a Q64.96
    /// @return tick The current tick function _staticcallSlot0Values(ad
    function _staticcallSlot0Values(address pool) internal view returns (uint160 sqrtPriceX96, int24 tick) {
        // slot0() function selector: 3850c7bd
        assembly {
            // Prepare calldata for staticcall (4 bytes for function selector)
            mstore(0x0, 0x3850c7bd00000000000000000000000000000000000000000000000000000000)
            
            // Perform staticcall
            // First 32 bytes: sqrtPriceX96 (uint160)
            // Next 32 bytes: tick (int24)
            let success := staticcall(gas(), pool, 0x0, 0x4, 0x0, 0x40)
            
            // Revert if call failed
            if iszero(success) {
                revert(0, 0)
            }

            // Load results
            sqrtPriceX96 := mload(0x0)    // First 32 bytes contain sqrtPriceX96
            tick := mload(0x20)           // Next 32 bytes contain tick
        }
    }

    /// @notice Reads the tick spacing from a Uniswap V3 pool using a static call
    /// @dev Makes a low-level staticcall to get the tick spacing value which determines valid tick intervals
    /// @dev Uses the tickSpacing() function selector (0xd0c93a7c) to make the call
    /// @param pool The address of the V3 pool to query
    /// @return spacing The tick spacing value for the pool (e.g. 60 for 0.6% fee tier)
    function _staticcallTickSpacing(address pool) internal view returns (int24 spacing) {
        assembly {
            // Store the function selector for tickSpacing()
            mstore(0, 0xd0c93a7c00000000000000000000000000000000000000000000000000000000)
            
            // Make the call
            let success := staticcall(gas(), pool, 0, 4, 0, 32)
            if iszero(success) { revert(0, 0) }
            
            // Load the result
            spacing := mload(0)
        }
    }

    
    // ┌─────────────────────────┐
    // │        Strings          │
    // └─────────────────────────┘
    /**
     * @dev Converts a uint256 to its ASCII string decimal representation.
     */
    function _toString(uint256 value) internal view virtual returns (string memory str) {
        assembly {
            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
            // We will need 1 word for the trailing zeros padding, 1 word for the length,
            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.
            let m := add(mload(0x40), 0xa0)
            // Update the free memory pointer to allocate.
            mstore(0x40, m)
            // Assign the `str` to the end.
            str := sub(m, 0x20)
            // Zeroize the slot after the string.
            mstore(str, 0)

            // Cache the end of the memory to calculate the length later.
            let end := str

            // We write the string from rightmost digit to leftmost digit.
            // The following is essentially a do-while loop that also handles the zero case.
            // prettier-ignore
            for { let temp := value } 1 {} {
                str := sub(str, 1)
                // Write the character to the pointer.
                // The ASCII index of the '0' character is 48.
                mstore8(str, add(48, mod(temp, 10)))
                // Keep dividing `temp` until zero.
                temp := div(temp, 10)
                // prettier-ignore
                if iszero(temp) { break }
            }

            let length := sub(end, str)
            // Move the pointer 32 bytes leftwards to make room for the length.
            str := sub(str, 0x20)
            // Store the length.
            mstore(str, length)
        }
    }
    
    // ┌─────────────────────────┐
    // │        Messages         │
    // └─────────────────────────┘
    /// @notice Packs timestamp, amount and buy flag into a single uint128 value
    /// @dev Packs data in the following format:
    ///      - timestamp: highest 32 bits
    ///      - amount: middle 95 bits (in ether, can store up to ~3.94e28 ether)
    ///      - isBuy flag: lowest bit
    /// @param timestamp The timestamp to pack (32 bits)
    /// @param amount The amount to pack (95 bits)
    /// @param isBuy The buy flag to pack (1 bit)
    /// @return packed The packed uint128 containing all data
    function packData(uint32 timestamp, uint96 amount, bool isBuy) internal pure returns (uint128) {
        return uint128(
            (uint128(timestamp) << 96) |  // timestamp in highest 32 bits
            (uint128(amount) << 1) |      // amount in middle 95 bits
            (isBuy ? 1 : 0)              // isBuy flag in lowest bit
        );
    }

    /// @notice Unpacks a uint128 value into timestamp, amount and buy flag components
    /// @dev Unpacks data from the following format:
    ///      - timestamp: highest 32 bits
    ///      - amount: middle 95 bits
    ///      - isBuy flag: lowest bit
    /// @param packed The packed uint128 to unpack
    /// @return timestamp The unpacked timestamp (32 bits)
    /// @return amount The unpacked amount (95 bits)
    /// @return isBuy The unpacked buy flag (1 bit)
    // function unpackData(uint128 packed) internal pure returns (uint32 timestamp, uint96 amount, bool isBuy) {
    //     timestamp = uint32(packed >> 96);
    //     amount = uint96(packed >> 1);
    //     isBuy = packed & 1 == 1;
    // }
    function unpackData(uint128 packed) internal pure returns (uint32 timestamp, uint96 amount, bool isBuy) {
        timestamp = uint32(packed >> 96);
        uint256 amountMask = (uint256(1) << 95) - 1;
        amount = uint96((packed >> 1) & amountMask);
        isBuy = (packed & 1) == 1;
    }

    // ┌─────────────────────────┐
    // │   Bonding Curve Math    │
    // └─────────────────────────┘

    /// **************************************************
    /// @dev The bonding curve formula is: P(s) = 12e-9 * S^3 + 4e-9 * S^2 + 4e-9 + 0.025 ether
    /// where:
    /// - S is the normalized supply (current supply / 10M tokens)
    /// - The polynomial terms create an accelerating price curve
    /// - Base price starts at 0.025 ETH per 10M tokens
    /// **************************************************

    /// @notice Calculates the integral of the bonding curve price function
    /// @dev Uses numerical integration to find the area under the price curve
    /// @param lowerBound The lower bound of the supply range to integrate
    /// @param upperBound The upper bound of the supply range to integrate
    /// @return integral The calculated integral value in ETH
    function calculateIntegral(uint256 lowerBound, uint256 upperBound) internal pure returns (uint256) {
        require(upperBound >= lowerBound, "Invalid bounds");
        return _calculateIntegralFromZero(upperBound) - _calculateIntegralFromZero(lowerBound);
    }

    /// @notice Calculates the integral of the bonding curve price function from zero to a given supply
    /// @dev Uses numerical integration to find the area under the price curve
    /// @param supply The upper bound of the supply range to integrate
    /// @return integral The calculated integral value in ETH
    function _calculateIntegralFromZero(uint256 supply) internal pure returns (uint256) {
        // Scale down to hundreds since price curve is per 10M tokens
        uint256 scaledSupplyWad = supply / 1e7;
        
        // Base price integral dewadded by 1e18
        uint256 basePart = INITIAL_PRICE * scaledSupplyWad / 1e18;
        
        // Calculate integral terms with scaled numbers
        uint256 quarticTerm = FixedPointMathLib.mulWad(
            //12 / 4 
            3 gwei,
            FixedPointMathLib.mulWad(
                FixedPointMathLib.mulWad(
                    FixedPointMathLib.mulWad(scaledSupplyWad, scaledSupplyWad),
                    scaledSupplyWad
                ),
                scaledSupplyWad
            )
        );
        
        uint256 cubicTerm = FixedPointMathLib.mulWad(
            1333333333, //4/3 * 1gwei
            FixedPointMathLib.mulWad(
                FixedPointMathLib.mulWad(scaledSupplyWad, scaledSupplyWad),
                scaledSupplyWad
            )
        );
        
        uint256 quadraticTerm = FixedPointMathLib.mulWad(
            2 gwei,
            FixedPointMathLib.mulWad(scaledSupplyWad, scaledSupplyWad)
        );
        
        // Scale the result back up by 1e8
        return basePart + quarticTerm + cubicTerm + quadraticTerm;
    }

    // ┌───────────────────────────────────────────────┐
    // │             Private Functions                 │
    // └───────────────────────────────────────────────┘

    /// @notice Initializes the CULT pool logic
    /// @dev Initializes the CULT pool by buying CULT with half of the ETH
    /// @dev Wraps the other half for the position
    /// @dev Approves tokens for the position manager
    /// @dev Calculates the tick ranges for the position
    /// @dev Creates a new position in the V3 pool
    function _initializeCultPoolLogic() private returns (bool success) {
        
        if (cultV3Position != 0 || cultPool == address(0)) {
            return false;
        }

        // Get current tick and calculate proper range
        int24 tickSpacing = _staticcallTickSpacing(cultPool);
        (,int24 currentTick) = _staticcallSlot0Values(cultPool);
        
        // Calculate ticks ±16 spacing units from current tick
        int24 tickRange = tickSpacing * 16;

        // Buy CULT with half the ETH
        uint256 cultBought = _buyCultWithExactEth(0.0025 ether);

        // Wrap the other half for the position
        //IWETH(weth).deposit{value: 0.005 ether}();
        _wethDeposit(0.0025 ether);

        // Approve tokens for position manager
        _erc20Approve(CULT, address(positionManager), cultBought);
        _erc20Approve(weth, address(positionManager), 0.0025 ether);
        
        // Calculate tick ranges
        int24 tickLower = ((currentTick - tickRange) / tickSpacing) * tickSpacing;
        int24 tickUpper = ((currentTick + tickRange) / tickSpacing) * tickSpacing;
        address _CULT = CULT;
        address _posMan = address(positionManager);
        bool isToken0 = CULT < weth;
        
        assembly {
            // Setup call to positionManager.mint()
            let ptr := mload(0x40)
            // Function selector for mint(MintParams)
            mstore(ptr, 0x8831645600000000000000000000000000000000000000000000000000000000)

            // Pack parameters based on token order
            // MintParams struct:
            // token0: address
            // token1: address  
            // fee: uint24
            // tickLower: int24
            // tickUpper: int24
            // amount0Desired: uint256
            // amount1Desired: uint256
            // amount0Min: uint256
            // amount1Min: uint256
            // recipient: address
            // deadline: uint256
            switch isToken0
            case 1 {
                // If CULT is token0
                mstore(add(ptr, 0x04), _CULT)           // token0 = CULT
                mstore(add(ptr, 0x24), weth)            // token1 = WETH
                mstore(add(ptr, 0xa4), cultBought)      // amount0Desired = cultBought
                mstore(add(ptr, 0xc4), 5000000000000000) // amount1Desired = 0.005 ETH
            }
            default {
                // If WETH is token0
                mstore(add(ptr, 0x04), weth)            // token0 = WETH
                mstore(add(ptr, 0x24), _CULT)           // token1 = CULT
                mstore(add(ptr, 0xa4), 5000000000000000) // amount0Desired = 0.005 ETH
                mstore(add(ptr, 0xc4), cultBought)      // amount1Desired = cultBought
            }

            // Common parameters
            mstore(add(ptr, 0x44), POOL_FEE)           // fee
            mstore(add(ptr, 0x64), tickLower)          // tickLower
            mstore(add(ptr, 0x84), tickUpper)          // tickUpper
            mstore(add(ptr, 0xe4), 0)                  // amount0Min
            mstore(add(ptr, 0x104), 0)                 // amount1Min
            mstore(add(ptr, 0x124), address())         // recipient = this contract
            mstore(add(ptr, 0x144), timestamp())       // deadline = current block timestamp

            // Make external call to position manager
            // Input size is 0x164 (356 bytes) - full MintParams struct
            // Output size is 0xA0 (160 bytes) - returns (tokenId, liquidity, amount0, amount1)
            success := call(gas(), _posMan, 0, ptr, 0x164, ptr, 0xA0)

            if success {
                // Store returned tokenId as cultV3Position
                sstore(cultV3Position.slot, mload(ptr))

                // Handle unused WETH refund if mint succeeded
                if iszero(lt(returndatasize(), 0xA0)) {
                    // Get actual amount1 used from return data
                    let amount1 := mload(add(ptr, 0x80))
                    let unusedWeth := sub(5000000000000000, amount1)

                    // Safety check on unusedWeth amount
                    if gt(unusedWeth, 0) {
                        if gt(unusedWeth, 5000000000000000) {
                            unusedWeth := 0
                        }

                        // Call WETH.withdraw() with unused amount
                        mstore(0x00, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                        mstore(0x04, unusedWeth)
                        pop(call(gas(), weth, 0, 0x00, 0x24, 0x00, 0x00))
                    }
                }
            }

            // If mint failed, withdraw all WETH
            if iszero(success) {
                mstore(0x00, 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000)
                mstore(0x04, 5000000000000000)
                pop(call(gas(), weth, 0, 0x00, 0x24, 0x00, 0x00))
            }
        }
    }

    // ┌───────────────────────────────────────────────┐
    // │               VIEW AND PURE                   │
    // └───────────────────────────────────────────────┘

    function name() public pure override returns (string memory) {
        return "CULT EXECUTIVES";
    }

    function symbol() public pure override returns (string memory) {
        return "EXEC";
    }

    /// @notice Calculates the cost of a given amount of EXEC tokens
    /// @dev Uses the bonding curve formula to calculate the cost
    /// @param amount The amount of EXEC tokens to calculate cost for
    /// @return cost The calculated cost in ETH
    function calculateCost(uint256 amount) public view returns (uint256) {
        return calculateIntegral(totalBondingSupply, totalBondingSupply + amount);
    }

    /// @notice Calculates the refund amount for a given amount of EXEC tokens
    /// @dev Uses the bonding curve formula to calculate the refund
    /// @param amount The amount of EXEC tokens to calculate refund for
    /// @return refund The calculated refund amount in ETH
    function calculateRefund(uint256 amount) public view returns (uint256) {
        return calculateIntegral(totalBondingSupply - amount, totalBondingSupply);
    }

    /// @notice Returns the token IDs owned by a specific address
    /// @dev Retrieves all token IDs owned by the address
    /// @param owner The address to check for owned tokens
    /// @return tokenIds The array of token IDs owned by the address
    function getOwnerTokens(address owner) public view returns (uint256[] memory) {
        uint256 ownerBalanceLength = _balanceOfNFT(owner);
        return _ownedIds(owner, 0, ownerBalanceLength);
    }
    
    /// @notice Returns the token URI for a given token ID
    /// @dev Retrieves the token URI for the specified token ID
    /// @param tokenId The ID of the token to get the URI for
    /// @return uri The token URI for the specified token ID
    function tokenURI(uint256 tokenId) public view returns (string memory) {
        return _tokenURI(tokenId);
    }

    /// @notice Verifies if an address is whitelisted using a Merkle proof
    /// @dev Uses the Merkle proof to verify if the address is whitelisted
    /// @param proof The Merkle proof for the address
    /// @param account The address to verify
    /// @return isWhitelisted True if the address is whitelisted, false otherwise
    function isWhitelisted(bytes32[] calldata proof, address account) public view returns (bool) {
        return MerkleProofLib.verify(
            proof,
            currentRoot(),
            // keccak256(abi.encodePacked(account))
            keccak256(abi.encodePacked(bytes20(account)))
        );
    }

    /// @notice Returns the current tier based on the timestamp
    /// @dev Calculates the current tier based on the timestamp
    /// @return currentTier The current tier
    function getCurrentTier() public view returns (uint256) {
        if (block.timestamp < LAUNCH_TIME) return 0;
        uint256 hoursSinceLaunch = (block.timestamp - LAUNCH_TIME) / 1 hours;
        return hoursSinceLaunch >= tierRoots.length ? tierRoots.length - 1 : hoursSinceLaunch;
    }

    /// @notice Returns the current tier's Merkle root
    /// @dev Retrieves the Merkle root for the current tier
    /// @return root The Merkle root for the current tier
    function currentRoot() public view returns (bytes32) {
        return tierRoots[getCurrentTier()];
    }

    /// @notice Calculates the amount of ETH required to purchase a given amount of EXEC tokens
    /// @dev Uses the bonding curve formula to calculate the cost
    /// @param execAmount The amount of EXEC tokens to calculate cost for
    /// @return ethAmount The calculated cost in ETH
    function getEthForExec(uint256 execAmount) public view returns (uint256 ethAmount) {
        require(execAmount <= totalBondingSupply, "Exceeds bonding");
        return calculateRefund(execAmount);
    }

    /// @notice Calculates the amount of EXEC tokens that can be purchased for a given amount of ETH
    /// @dev Uses binary search to find the amount of EXEC that costs closest to the given ETH amount
    /// @param ethAmount The amount of ETH to calculate the amount of EXEC for
    /// @return execAmount The calculated amount of EXEC tokens
    function getExecForEth(uint256 ethAmount) public view returns (uint256 execAmount) {
        // If price is too low, return max possible
        uint256 remainingSupply = MAX_SUPPLY - LIQUIDITY_RESERVE - totalBondingSupply;
        if (calculateCost(remainingSupply) <= ethAmount) {
            return remainingSupply;
        }

        // Binary search for the amount of EXEC that costs closest to ethAmount
        uint256 low = 0;
        uint256 high = remainingSupply;
        
        while (low < high) {
            uint256 mid = (low + high + 1) / 2;
            uint256 cost = calculateCost(mid);
            
            if (cost <= ethAmount) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        
        return low;
    }

}
